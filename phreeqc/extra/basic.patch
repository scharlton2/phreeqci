--- basic.c	2010-02-19 18:52:54.353731300 -0700
+++ basic1.c	2010-02-19 18:45:48.491552700 -0700
@@ -3,20 +3,30 @@
 
 #if !defined(PHREEQC_CLASS)
 #define EXTERNAL extern
-#include "global.h"
+#include "../src/global.h"
 #else
 typedef unsigned char boolean;
-#include "Phreeqc.h"
+#include "../src/Phreeqc.h"
 #endif
 
-#include "phqalloc.h"
-#include "output.h"
-#include "phrqproto.h"
-#include "p2c.h"
+#include "../src/phqalloc.h"
+#include "../src/output.h"
+#include "../src/phrqproto.h"
+#include "../src/p2c.h"
 #if !defined(PHREEQC_CLASS)
 static char const svnid[] = "$Id: basic.c 4083 2010-02-19 05:21:13Z charlton $";
 
 int n_user_punch_index;
+
+#ifdef PHREEQCI_GUI
+#define cmd_free        cmd_free_1
+#define cmd_initialize  cmd_initialize_1
+#define basic_renumber  basic_renumber_1
+#define basic_run       basic_run_1
+#define basic_compile   basic_compile_1
+#define basic_main      basic_main_1
+#endif /* PHREEQCI_GUI */
+
 #ifdef PHREEQ98
 void GridChar(char *s, char *a);
 extern int colnr, rownr;
@@ -24,7 +34,7 @@
 
 static int sget_logical_line(char **ptr, int *l, char *return_line);
 
-#include "basic.h"
+#include "../src/basic.h"
 
 Static Char *inbuf;
 Static linerec *linebase;
@@ -35,12 +45,27 @@
 Static tokenrec *stmttok, *datatok, *buf;
 Static boolean exitflag;
 
+#ifdef PHREEQCI_GUI
+Static int parse_whole_program;
+static HANDLE s_hInfiniteLoop = 0;
+UINT g_nIDErrPrompt;
+int g_nErrLineNumber;
+#include "../../resource.h"
+#endif /* PHREEQCI_GUI */
+
 Static int free_dim_stringvar(struct varrec *varbase);
 extern long EXCP_LINE;
 Static void parseinput(tokenrec ** buf);
 Static void exec(void);
 Static void disposetokens(tokenrec ** tok);
 
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+				  int parse_whole_program_flag);
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+			  int parse_whole_program_flag, HANDLE hInfiniteLoop);
+#endif /* PHREEQCI_GUI */
+
 /*$if not checking$
    $range off$
 $end$*/
@@ -257,11 +282,22 @@
 	return 0;
 }
 #endif
+#ifdef PHREEQCI_GUI
+int CLASS_QUALIFIER
+basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+			  int parse_whole_program_flag)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(P_escapecode == 0);
+	_ASSERTE(g_nIDErrPrompt == 0);
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	/*
 	if (svnid == NULL)
 		fprintf(stderr, " ");
@@ -275,6 +311,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	do
 	{
@@ -303,13 +342,21 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			putchar('\n');
+#endif /* PHREEQCI_GUI */
 		}
 		ENDTRY(try2);
 	}
@@ -319,6 +366,9 @@
 	*lnbase = (void *) linebase;
 	*vbase = (void *) varbase;
 	*lpbase = (void *) loopbase;
+#ifndef PHREEQCI_GUI
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
@@ -400,11 +450,22 @@
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+int CLASS_QUALIFIER
+basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+		  int parse_whole_program_flag, HANDLE hInfiniteLoop)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_run(char *commands, void *lnbase, void *vbase, void *lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(s_hInfiniteLoop == 0);
+	s_hInfiniteLoop = hInfiniteLoop;
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	PASCAL_MAIN(0, NULL);
 	inbuf = (char *) PHRQ_calloc(max_line, sizeof(char));
 	if (inbuf == NULL)
@@ -413,6 +474,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	linebase = (linerec *) lnbase;
 	varbase = (varrec *) vbase;
@@ -443,9 +507,13 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
@@ -457,9 +525,23 @@
 
 	/*  exit(EXIT_SUCCESS); */
 	free(inbuf);
+#ifdef PHREEQCI_GUI
+	s_hInfiniteLoop = 0;
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+void
+basic_free(void *lnbase, void *vbase, void *lpbase)
+{
+	basic_run("new; quit", lnbase, vbase, lpbase, FALSE, s_hInfiniteLoop);
+	lnbase = NULL;
+	vbase = NULL;
+	lpbase = NULL;
+}
+#endif /* PHREEQCI_GUI */
+
 int CLASS_QUALIFIER
 basic_main(char *commands)
 {								/*main */
@@ -755,6 +837,10 @@
 				tptr->next = t;
 			tptr = t;
 			t->next = NULL;
+#ifdef PHREEQCI_GUI
+			t->n_sz = 0;
+			t->sz_num = 0;
+#endif
 			switch (ch)
 			{
 
@@ -1213,6 +1299,25 @@
 						i++;
 						break;
 					}
+#ifdef PHREEQCI_GUI
+					_ASSERTE(t->n_sz == 0);
+					_ASSERTE(t->sz_num == NULL);
+					t->n_sz = max(23, ptr - &inbuf[i - 1]);
+					t->sz_num =
+						(char *) PHRQ_calloc((t->n_sz + 1), sizeof(char));
+					if (t->sz_num == NULL)
+						malloc_error();
+					if (ptr > &inbuf[i - 1])
+					{
+						strncpy(t->sz_num, &inbuf[i - 1],
+								(ptr - &inbuf[i - 1]));
+						t->sz_num[ptr - &inbuf[i - 1]] = '\0';
+					}
+					else
+					{
+						t->sz_num[0] = '\0';
+					}
+#endif /* PHREEQCI_GUI */
 					i += (int) (ptr - &inbuf[i - 1]);
 				}
 				else
@@ -1865,6 +1970,18 @@
 	while (*tok != NULL)
 	{
 		tok1 = (*tok)->next;
+#ifdef PHREEQCI_GUI
+		if ((*tok)->kind == (long) toknum)
+		{
+			free((*tok)->sz_num);
+		}
+#ifdef _DEBUG
+		else
+		{
+			_ASSERTE((*tok)->sz_num == NULL);
+		}
+#endif /* _DEBUG */
+#endif /* PHREEQCI_GUI */
 		if ((*tok)->kind == (long) tokrem || (*tok)->kind == (long) tokstr)
 		{
 			(*tok)->UU.sp = (char *) free_check_null((*tok)->UU.sp);
@@ -1939,7 +2056,12 @@
 #ifdef SKIP
 	printf("\007%s", s);
 #endif
+#ifdef PHREEQCI_GUI
+	/* set g_nIDErrPrompt before calling errormsg see snerr */
+	_ASSERTE(g_nIDErrPrompt != 0);
+#else /* PHREEQCI_GUI */
 	error_msg(s, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	_Escape(42);
 }
 
@@ -1949,6 +2071,10 @@
 {
   char str[MAX_LENGTH] = {0};
   strcpy(str, "Syntax_error ");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_SYNTAX;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -1958,6 +2084,10 @@
 {
   char str[MAX_LENGTH] = {0};
   strcpy(str, "Type mismatch error");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_MISMATCH;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -1965,6 +2095,10 @@
 Static void CLASS_QUALIFIER
 badsubscr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_BAD_SUBSCRIPT;
+#endif /* PHREEQCI_GUI */
 	errormsg("Bad subscript");
 }
 
@@ -2196,7 +2330,9 @@
 	long i, j, m;
 	tokenrec *tok, *tok1;
 	Char *s;
+#ifdef PARSE_ALL
 	LDBLE dummy;
+#endif
 	int i_rate;
 	union
 	{
@@ -2204,7 +2340,9 @@
 		Char *c;
 	} trick;
 	struct save_values s_v, *s_v_ptr;
+#ifdef PARSE_ALL
 	int k;
+#endif
 	LDBLE TEMP;
 	Char STR1[256] = {0}, STR2[256] = {0};
 	char *elt_name, *surface_name, *mytemplate, *name;
@@ -2379,27 +2517,47 @@
 
 	case tokparm:
 		i_rate = intfactor(LINK);
+#ifdef PARSE_ALL
 		if (i_rate > count_rate_p || i_rate == 0)
 		{
 			errormsg("Parameter subscript out of range.");
 		}
 		n.UU.val = rate_p[i_rate - 1];
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokact:
+#ifdef PARSE_ALL
 		n.UU.val = activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokgamma:
+#ifdef PARSE_ALL
 		n.UU.val = activity_coefficient(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklg:
+#ifdef PARSE_ALL
 		n.UU.val = log_activity_coefficient(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokget_por:
 		i = intfactor(LINK);
+#ifdef PARSE_ALL
 		if (phast != TRUE)
 		{
 			if (i <= 0 || i > count_cells * (1 + stag_data->count_stag) + 1
@@ -2417,6 +2575,10 @@
 			n.UU.val = cell_porosity;
 			break;
 		}
+#else
+		n.UU.val = 1;
+		break;
+#endif
 
 	case tokedl:
 		require(toklp, LINK);
@@ -2431,7 +2593,11 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = diff_layer_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksurf:
@@ -2447,31 +2613,65 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = surf_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokequi:
+#ifdef PARSE_ALL
 		n.UU.val = equi_phase(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokkin:
+#ifdef PARSE_ALL
 		n.UU.val = kinetics_moles(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokgas:
+#ifdef PARSE_ALL
 		n.UU.val = find_gas_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toks_s:
+#ifdef PARSE_ALL
 		n.UU.val = find_s_s_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc1:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc1(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc2:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc2(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmu:
@@ -2490,19 +2690,38 @@
 		break;
 
 	case tokalk:
+#ifdef PARSE_ALL
 		n.UU.val = total_alkalinity / mass_water_aq_x;
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_species:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_s(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_named:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_n(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_phase:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_p(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toksum_species:
@@ -2518,7 +2737,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_species(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_gas:
@@ -2534,7 +2757,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_gases(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_s_s:
@@ -2550,14 +2777,22 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_s_s(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokcalc_value:
 		require(toklp, LINK);
 		name = stringfactor(STR1, LINK);
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = get_calculate_value(name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokdescription:
@@ -2713,10 +2948,10 @@
 		/*
 		   n.UU.val = system_total(elt_name, count_varrec->UU.U0.val, &(names_varrec->UU.U1.sarr), &(types_varrec->UU.U1.sarr), &(moles_varrec->UU.U0.arr));
 		 */
+#ifdef PARSE_ALL
 		n.UU.val =
 			system_total(elt_name, &count_species, &(names_arg),
 						 &(types_arg), &(moles_arg));
-
 		/*
 		 *  fill in varrec structure
 		 */
@@ -2751,6 +2986,9 @@
 			free_check_null(types_arg);
 			free_check_null(moles_arg);
 		}
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 	case tokrxn:
 		if (state == REACTION)
@@ -2783,19 +3021,39 @@
 		break;
 
 	case tokmol:
+#ifdef PARSE_ALL
 		n.UU.val = molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokla:
+#ifdef PARSE_ALL
 		n.UU.val = log_activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toklm:
+#ifdef PARSE_ALL
 		n.UU.val = log_molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksr:
+#ifdef PARSE_ALL
 		n.UU.val = saturation_ratio(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokstep_no:
@@ -2822,6 +3080,7 @@
 		break;
 
 	case tokcell_no:
+#ifdef PARSE_ALL
 		if (state == TRANSPORT)
 		{
 			n.UU.val = cell_no;
@@ -2850,6 +3109,10 @@
 			}
 		}
 		break;
+#else
+		n.UU.val = 1;
+		break;
+#endif
 
 	case toksim_no:
 		n.UU.val = simulation;
@@ -2908,10 +3171,18 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
+#else
+		s_v_ptr = NULL;
+#endif
 		if (s_v_ptr == NULL)
 		{
+#ifdef PARSE_ALL
 			n.UU.val = 0;
+#else
+			n.UU.val = 1;
+#endif
 		}
 		else
 		{
@@ -2972,6 +3243,7 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
 		if (s_v_ptr == NULL)
 		{
@@ -2981,22 +3253,43 @@
 		{
 			n.UU.val = 1;
 		}
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokcharge_balance:
+#ifdef PARSE_ALL
 		n.UU.val = cb_x;
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokpercent_error:
+#ifdef PARSE_ALL
 		n.UU.val = 100 * cb_x / total_ions_x;
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksi:
+#ifdef PARSE_ALL
 		saturation_index(stringfactor(STR1, LINK), &dummy, &n.UU.val);
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toktot:
+#ifdef PARSE_ALL
 		n.UU.val = total(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokcell_pore_volume:
@@ -3006,7 +3299,11 @@
 
 /* VP : Density Start */
 	case tokrho:
+#ifdef PARSE_ALL
 		n.UU.val = calc_dens();
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 /* VP: Density End */
 	case tokcell_volume:
@@ -3019,7 +3316,11 @@
 		n.UU.val = cell_saturation;
 		break;
 	case toksc:
+#ifdef PARSE_ALL
 		n.UU.val = calc_SC();
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toklog10:
@@ -3144,8 +3445,13 @@
 
 	case tokpeek:
 /* p2c: basic.p, line 1029: Note: Range checking is OFF [216] */
+#ifdef PARSE_ALL
 		trick.i = intfactor(LINK);
 		n.UU.val = *trick.c;
+#else
+		intfactor(LINK);
+		n.UU.val = 1.0;
+#endif
 /* p2c: basic.p, line 1032: Note: Range checking is ON [216] */
 		break;
 
@@ -3229,8 +3535,10 @@
 		}
 		else
 		{
+#ifdef PARSE_ALL
 			sprintf(error_string, "Zero divide in BASIC line\n %ld %s.\nValue set to zero.", stmtline->num, stmtline->inbuf);
 			warning_msg(error_string, CONTINUE);
+#endif
 			n.UU.val = 0;
 		}
 	}
@@ -3400,7 +3708,15 @@
 checkextra(struct LOC_exec *LINK)
 {
 	if (LINK->t != NULL)
+#ifdef PHREEQCI_GUI
+	{
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_EXTRA;
+#endif /* PHREEQCI_GUI */
 		errormsg("Extra information on line");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3450,10 +3766,21 @@
 	l = findline(n, LINK);
 #endif
 	l = findline(n);
-	if (l == NULL) {
-		sprintf(error_string, "Undefined line %ld", n);
-		errormsg(error_string);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (l == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_UNDEF_LINE;
+#endif /* PHREEQCI_GUI */
+			errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+		}
 	}
+#endif /* PHREEQCI_GUI */
 	return l;
 }
 
@@ -3766,7 +4093,9 @@
 		}
 	}
 
+#ifdef PARSE_ALL
 	save_values_store(&s_v);
+#endif
 	s_v.subscripts = (int *) free_check_null(s_v.subscripts);
 }
 
@@ -3949,7 +4278,14 @@
 						printf("Undefined line %ld in line %ld\n", lnum,
 							   l->num2);
 					else
+#ifdef PHREEQCI_GUI
+					{
+						_snprintf(tok->sz_num, tok->n_sz, "%ld", l1->num2);
+#endif /* PHREEQCI_GUI */
 						tok->UU.num = l1->num2;
+#ifdef PHREEQCI_GUI
+					}
+#endif /* PHREEQCI_GUI */
 					if (tok->next != NULL && tok->next->kind == tokcomma)
 						tok = tok->next;
 				}
@@ -4425,6 +4761,10 @@
 				if (stmtline == NULL || stmtline->next == NULL)
 				{
 					stmtline = saveline;
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_FOR_WO_NEXT;
+#endif /* PHREEQCI_GUI */
 					errormsg("FOR without NEXT");
 				}
 				stmtline = stmtline->next;
@@ -4474,7 +4814,15 @@
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_NEXT_WO_FOR;
+#endif /* PHREEQCI_GUI */
 			errormsg("NEXT without FOR");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == forloop &&
 						   (v == NULL || loopbase->UU.U0.vp == v));
 		if (!found)
@@ -4519,12 +4867,27 @@
 		return;
 	if (realexpr(LINK) != 0)
 		return;
-	if (!skiploop(tokwhile, tokwend, LINK))
-		errormsg("WHILE without WEND");
-	l = loopbase->next;
-	free(loopbase);
-	loopbase = l;
-	skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (!skiploop(tokwhile, tokwend, LINK))
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WHILE_WO_WEND;
+#endif /* PHREEQCI_GUI */
+			errormsg("WHILE without WEND");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
+		l = loopbase->next;
+		free(loopbase);
+		loopbase = l;
+		skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -4536,10 +4899,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WEND_WO_WHILE;
+#endif /* PHREEQCI_GUI */
 			errormsg("WEND without WHILE");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == whileloop);
 		if (!found)
 		{
@@ -4599,10 +4976,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_RETURN_WO_GOSUB;
+#endif /* PHREEQCI_GUI */
 			errormsg("RETURN without GOSUB");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == gosubloop);
 		if (!found)
 		{
@@ -4633,37 +5024,52 @@
 		v = findvar(LINK);
 		tok = LINK->t;
 		LINK->t = datatok;
-		if (dataline == NULL)
-		{
-			dataline = linebase;
-			LINK->t = dataline->txt;
-		}
-		if (LINK->t == NULL || LINK->t->kind != tokcomma)
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
 		{
-			do
+#endif /* PHREEQCI_GUI */
+			if (dataline == NULL)
+			{
+				dataline = linebase;
+				LINK->t = dataline->txt;
+			}
+			if (LINK->t == NULL || LINK->t->kind != tokcomma)
 			{
-				while (LINK->t == NULL)
+				do
 				{
-					if (dataline == NULL || dataline->next == NULL)
-						errormsg("Out of Data");
-					dataline = dataline->next;
-					LINK->t = dataline->txt;
+					while (LINK->t == NULL)
+					{
+						if (dataline == NULL || dataline->next == NULL)
+#ifdef PHREEQCI_GUI
+						{
+							_ASSERTE(g_nIDErrPrompt == 0);
+							g_nIDErrPrompt = IDS_ERR_OUT_OF_DATA;
+#endif /* PHREEQCI_GUI */
+							errormsg("Out of Data");
+#ifdef PHREEQCI_GUI
+						}
+#endif /* PHREEQCI_GUI */
+						dataline = dataline->next;
+						LINK->t = dataline->txt;
+					}
+					found = (boolean) (LINK->t->kind == tokdata);
+					LINK->t = LINK->t->next;
 				}
-				found = (boolean) (LINK->t->kind == tokdata);
+				while (!found || iseos(LINK));
+			}
+			else
 				LINK->t = LINK->t->next;
+			if (v->stringvar)
+			{
+				if (*v->UU.U1.sval != NULL)
+					*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
+				*v->UU.U1.sval = strexpr(LINK);
 			}
-			while (!found || iseos(LINK));
-		}
-		else
-			LINK->t = LINK->t->next;
-		if (v->stringvar)
-		{
-			if (*v->UU.U1.sval != NULL)
-				*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
-			*v->UU.U1.sval = strexpr(LINK);
+			else
+				*v->UU.U0.val = realexpr(LINK);
+#ifdef PHREEQCI_GUI
 		}
-		else
-			*v->UU.U0.val = realexpr(LINK);
+#endif /* PHREEQCI_GUI */
 		datatok = LINK->t;
 		LINK->t = tok;
 		if (!iseos(LINK))
@@ -4691,7 +5097,14 @@
 		dataline = mustfindline(intexpr(LINK), LINK);
 #endif
 		dataline = mustfindline(intexpr(LINK));
-		datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
+		{
+#endif /* PHREEQCI_GUI */
+			datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 	}
 }
 
@@ -4761,7 +5174,15 @@
 		v = LINK->t->UU.vp;
 		LINK->t = LINK->t->next;
 		if (v->numdims != 0)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_ARRAY_ALREADY;
+#endif /* PHREEQCI_GUI */
 			errormsg("Array already dimensioned before");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		j = 1;
 		i = 0;
 		require(toklp, LINK);
@@ -4841,6 +5262,13 @@
 			if (V.t != NULL)
 			{
 				V.t = V.t->next;
+#ifdef PHREEQCI_GUI
+				if (WaitForSingleObject(s_hInfiniteLoop, 0) == WAIT_OBJECT_0)
+				{
+					g_nIDErrPrompt = IDS_ERR_INFINITE_LOOP;
+					errormsg("Possible infinite loop");
+				}
+#endif /* PHREEQCI_GUI */
 				switch (stmttok->kind)
 				{
 
@@ -4930,9 +5358,16 @@
 #endif
 
 				case tokinput:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_INPUT_NOTLEGAL;
+					errormsg
+						("Basic command INPUT is not a legal command in PHREEQC.");
+#else /* PHREEQCI_GUI */
 					error_msg
 						("Basic command INPUT is not a legal command in PHREEQC.",
 						 STOP);
+#endif /* PHREEQCI_GUI */
 #ifdef SKIP
 					cmdinput(&V);
 #endif
@@ -5011,6 +5446,10 @@
 					break;
 
 				default:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_ILLEGAL;
+#endif /* PHREEQCI_GUI */
 					errormsg("Illegal command");
 					break;
 				}
@@ -5110,8 +5549,13 @@
 	}
 	if (stmtline != NULL)
 	{
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nErrLineNumber == 0);
+		g_nErrLineNumber = stmtline->num;
+#else /* PHREEQCI_GUI */
 		sprintf(error_string, " in BASIC line\n %ld %s", stmtline->num, stmtline->inbuf);
 		error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	}
 #ifdef SKIP
 	printf(" in %ld", stmtline->num);
