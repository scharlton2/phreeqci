--- basic.c	2006-10-20 22:09:09.781250000 -0600
+++ basic1.c	2006-10-20 22:06:14.562500000 -0600
@@ -5,18 +5,28 @@
 static char const svnid[] = "$Id: basic.c 1334 2006-10-18 20:30:13Z dlpark $";
 
 #define EXTERNAL extern
-#include "global.h"
-#include "phqalloc.h"
-#include "output.h"
-#include "phrqproto.h"
+#include "../src/global.h"
+#include "../src/phqalloc.h"
+#include "../src/output.h"
+#include "../src/phrqproto.h"
 
 int n_user_punch_index;
+
+#ifdef PHREEQCI_GUI
+#define cmd_free        cmd_free_1
+#define cmd_initialize  cmd_initialize_1
+#define basic_renumber  basic_renumber_1
+#define basic_run       basic_run_1
+#define basic_compile   basic_compile_1
+#define basic_main      basic_main_1
+#endif /* PHREEQCI_GUI */
+
 #ifdef PHREEQ98
 void GridChar(char* s, char* a);
 extern int colnr, rownr;
 #endif
 
-#include "p2c.h"
+#include "../src/p2c.h"
 
 static int sget_logical_line(char **ptr, int *l, char *return_line);
 
@@ -180,6 +190,10 @@
     Char *sp;
     Char snch;
   } UU;
+#ifdef PHREEQCI_GUI
+  size_t n_sz;
+  Char *sz_num;
+#endif /* PHREEQCI_GUI */
 } tokenrec;
 
 typedef struct linerec {
@@ -237,12 +251,25 @@
 Static tokenrec *stmttok, *datatok, *buf;
 Static boolean exitflag;
 
+#ifdef PHREEQCI_GUI
+Static int parse_whole_program;
+static HANDLE s_hInfiniteLoop = 0;
+UINT g_nIDErrPrompt;
+int g_nErrLineNumber;
+#include "../../resource.h"
+#endif /* PHREEQCI_GUI */
+
 Static int free_dim_stringvar(struct varrec *varbase);
 extern long EXCP_LINE;
 Static void parseinput(tokenrec **buf);
 Static void exec(void);
 Static void disposetokens(tokenrec **tok);
 
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase, int parse_whole_program_flag);
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase, int parse_whole_program_flag, HANDLE hInfiniteLoop);
+#endif /* PHREEQCI_GUI */
+
 /*$if not checking$
    $range off$
 $end$*/
@@ -402,7 +429,6 @@
  */
 
 	hdestroy_multi(command_hash_table);
-        command_hash_table = NULL;
 	return;
 }
 
@@ -414,10 +440,19 @@
 	return 0;
 }
 #endif
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase, int parse_whole_program_flag)
+#else /* PHREEQCI_GUI */
 int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase)
+#endif /* PHREEQCI_GUI */
 {				/*main*/
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(P_escapecode == 0);
+	_ASSERTE(g_nIDErrPrompt == 0);
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	if (svnid == NULL) fprintf(stderr," ");
 
 	PASCAL_MAIN(0, NULL);
@@ -427,6 +462,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	do {
 		TRY(try2);
@@ -449,10 +487,18 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int)P_escapecode, (int)P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 		        sprintf(error_string,"%d/%d",(int)P_escapecode, (int)P_ioresult);
 			error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		} else {
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			putchar('\n');
+#endif /* PHREEQCI_GUI */
 		}
 		ENDTRY(try2);
 	} while (!(exitflag || P_eof()));
@@ -461,6 +507,9 @@
 	*lnbase = (void *) linebase;
 	*vbase = (void *) varbase;
 	*lpbase = (void *) loopbase;
+#ifndef PHREEQCI_GUI
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return(P_escapecode);
 }
 int basic_renumber(char *commands, void **lnbase, void **vbase, void **lpbase)
@@ -521,10 +570,19 @@
 
 	return(P_escapecode);
 }
+#ifdef PHREEQCI_GUI
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase, int parse_whole_program_flag, HANDLE hInfiniteLoop)
+#else /* PHREEQCI_GUI */
 int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase)
+#endif /* PHREEQCI_GUI */
 {				/*main*/
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(s_hInfiniteLoop == 0);
+	s_hInfiniteLoop = hInfiniteLoop;
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	PASCAL_MAIN(0,NULL);
 	inbuf = (char *) PHRQ_calloc(max_line, sizeof(char));
 	if ( inbuf == NULL) malloc_error();
@@ -532,6 +590,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	linebase = (linerec *) lnbase;
 	varbase = (varrec *) vbase;
@@ -556,8 +617,12 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int)P_escapecode, (int)P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 		        sprintf(error_string,"%d/%d",(int)P_escapecode, (int)P_ioresult);
 			error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		} else {
 			putchar('\n');
 		}
@@ -566,8 +631,24 @@
 
 	/*  exit(EXIT_SUCCESS); */
 	free(inbuf);
+#ifdef PHREEQCI_GUI
+	s_hInfiniteLoop = 0;
+#else /* PHREEQCI_GUI */
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return(P_escapecode);
 }
+
+#ifdef PHREEQCI_GUI
+void basic_free(void *lnbase, void *vbase, void *lpbase)
+{
+	basic_run("new; quit", lnbase, vbase, lpbase, FALSE, s_hInfiniteLoop);
+	lnbase = NULL;
+	vbase = NULL;
+	lpbase = NULL;
+}
+#endif /* PHREEQCI_GUI */
+
 int basic_main(char *commands)
 {  /*main*/
 	int l;
@@ -1228,6 +1309,22 @@
 		  i++;
 		  break;
 	  }
+#ifdef PHREEQCI_GUI
+	  _ASSERTE(t->n_sz   == 0);
+	  _ASSERTE(t->sz_num == NULL);
+	  t->n_sz = max(23, ptr - &inbuf[i-1]);
+	  t->sz_num = (char *) PHRQ_malloc((t->n_sz + 1) * sizeof(char));
+	  if (t->sz_num == NULL) malloc_error();
+	  if (ptr > &inbuf[i-1])
+	  {
+		  strncpy(t->sz_num, &inbuf[i-1], (ptr - &inbuf[i-1]));
+		  t->sz_num[ptr - &inbuf[i-1]] = '\0';
+	  }
+	  else
+	  {
+		  t->sz_num[0] = '\0';
+	  }
+#endif /* PHREEQCI_GUI */
 	  i += (int) (ptr - &inbuf[i-1]);
 	} else {
 	  t->kind = toksnerr;
@@ -1825,6 +1922,18 @@
 
   while (*tok != NULL) {
     tok1 = (*tok)->next;
+#ifdef PHREEQCI_GUI
+	if ((*tok)->kind == (long)toknum)
+	{
+		free((*tok)->sz_num);
+	}
+#ifdef _DEBUG
+	else
+	{
+		_ASSERTE((*tok)->sz_num == NULL);
+	}
+#endif /* _DEBUG */
+#endif /* PHREEQCI_GUI */
     if ((*tok)->kind == (long)tokrem || (*tok)->kind == (long)tokstr) {
 	    (*tok)->UU.sp = (char*) free_check_null((*tok)->UU.sp);
     }
@@ -1889,25 +1998,42 @@
 #ifdef SKIP
   printf("\007%s", s);
 #endif
+#ifdef PHREEQCI_GUI
+  /* set g_nIDErrPrompt before calling errormsg see snerr */
+  _ASSERTE(g_nIDErrPrompt != 0);
+#else /* PHREEQCI_GUI */
   error_msg(s, CONTINUE);
+#endif /* PHREEQCI_GUI */
   _Escape(42);
 }
 
 
 Static void snerr(void)
 {
+#ifdef PHREEQCI_GUI
+  _ASSERTE(g_nIDErrPrompt == 0);
+  g_nIDErrPrompt = IDS_ERR_SYNTAX;
+#endif /* PHREEQCI_GUI */
   errormsg("Syntax error");
 }
 
 
 Static void tmerr(void)
 {
+#ifdef PHREEQCI_GUI
+  _ASSERTE(g_nIDErrPrompt == 0);
+  g_nIDErrPrompt = IDS_ERR_MISMATCH;
+#endif /* PHREEQCI_GUI */
   errormsg("Type mismatch error");
 }
 
 
 Static void badsubscr(void)
 {
+#ifdef PHREEQCI_GUI
+  _ASSERTE(g_nIDErrPrompt == 0);
+  g_nIDErrPrompt = IDS_ERR_BAD_SUBSCRIPT;
+#endif /* PHREEQCI_GUI */
   errormsg("Bad subscript");
 }
 
@@ -2108,14 +2234,18 @@
   long i, j, m;
   tokenrec *tok, *tok1;
   Char *s;
+#ifdef PARSE_ALL
   LDBLE dummy;
+#endif
   int i_rate;
   union {
     long i;
     Char *c;
   } trick;
   struct save_values s_v, *s_v_ptr;
+#ifdef PARSE_ALL
   int k;
+#endif
   LDBLE TEMP;
   Char *STR1, *STR2;
   char *elt_name, *surface_name, *mytemplate, *name;
@@ -2169,7 +2299,7 @@
 	    if (*v->UU.U1.sval != NULL) {
 		    strcpy(n.UU.sval, *v->UU.U1.sval);
 	    }
-		   
+
     } else
       n.UU.val = *v->UU.U0.val;
     break;
@@ -2258,14 +2388,23 @@
 
   case tokparm:
     i_rate = intfactor(LINK);
+#ifdef PARSE_ALL
     if ( i_rate > count_rate_p) {
 	    errormsg("Parameter subscript out of range.");
     }
     n.UU.val = rate_p[i_rate - 1];
+#else
+    n.UU.val = 1;
+#endif
     break;
 
   case tokact:
+#ifdef PARSE_ALL
     n.UU.val = activity(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1;
+#endif
     break;
 
   case tokget_por:
@@ -2287,7 +2426,11 @@
       surface_name = NULL;
     }
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = diff_layer_total(elt_name, surface_name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toksurf:
@@ -2300,31 +2443,65 @@
       surface_name = NULL;
     }
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = surf_total(elt_name, surface_name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokequi:
+#ifdef PARSE_ALL
     n.UU.val = equi_phase(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokkin:
+#ifdef PARSE_ALL
     n.UU.val = kinetics_moles(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokgas:
+#ifdef PARSE_ALL
     n.UU.val = find_gas_comp(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toks_s:
+#ifdef PARSE_ALL
     n.UU.val = find_s_s_comp(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokmisc1:
+#ifdef PARSE_ALL
     n.UU.val = find_misc1(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokmisc2:
+#ifdef PARSE_ALL
     n.UU.val = find_misc2(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokmu:
@@ -2344,15 +2521,30 @@
     break;
 
   case toklk_species:
+#ifdef PARSE_ALL
     n.UU.val = calc_logk_s(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1;
+#endif
     break;
 
   case toklk_named:
+#ifdef PARSE_ALL
     n.UU.val = calc_logk_n(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1;
+#endif
     break;
 
   case toklk_phase:
+#ifdef PARSE_ALL
     n.UU.val = calc_logk_p(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1;
+#endif
     break;
 
   case toksum_species:
@@ -2365,7 +2557,11 @@
       elt_name = NULL;
     }
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = sum_match_species(mytemplate, elt_name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toksum_gas:
@@ -2378,7 +2574,11 @@
       elt_name = NULL;
     }
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = sum_match_gases(mytemplate, elt_name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toksum_s_s:
@@ -2391,14 +2591,22 @@
       elt_name = NULL;
     }
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = sum_match_s_s(mytemplate, elt_name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokcalc_value:
     require(toklp, LINK);
     name = stringfactor(STR1, LINK);
     require(tokrp, LINK);
+#ifdef PARSE_ALL
     n.UU.val = get_calculate_value(name);
+#else
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokdescription:
@@ -2518,7 +2726,7 @@
 
 	  if (arg_num > 1) {
 		  free_dim_stringvar(names_varrec);
-		  free_dim_stringvar(types_varrec); 
+		  free_dim_stringvar(types_varrec);
 		  free_check_null(moles_varrec->UU.U0.arr);
 		  moles_varrec->UU.U0.arr = NULL;
 	  }
@@ -2581,19 +2789,39 @@
     break;
 
   case tokmol:
+#ifdef PARSE_ALL
     n.UU.val = molality(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokla:
+#ifdef PARSE_ALL
     n.UU.val = log_activity(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toklm:
+#ifdef PARSE_ALL
     n.UU.val = log_molality(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toksr:
+#ifdef PARSE_ALL
     n.UU.val = saturation_ratio(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case tokstep_no:
@@ -2610,6 +2838,7 @@
     }
     break;
 
+#ifdef PARSE_ALL
   case tokcell_no:
     if (state == TRANSPORT) {
 	    n.UU.val = cell_no;
@@ -2627,6 +2856,11 @@
 	    }
     }
     break;
+#else
+  case tokcell_no:
+    n.UU.val = 1;
+    break;
+#endif
 
   case toksim_no:
 	  n.UU.val = simulation;
@@ -2660,9 +2894,17 @@
 			  break;
 		  }
 	  }
+#ifdef PARSE_ALL
 	  s_v_ptr = save_values_bsearch(&s_v, &k);
+#else
+	  s_v_ptr = NULL;
+#endif
 	  if (s_v_ptr == NULL) {
+#ifdef PARSE_ALL
 		  n.UU.val = 0;
+#else
+		  n.UU.val = 1;
+#endif
 	  } else {
 		  n.UU.val = s_v_ptr->value;
 	  }
@@ -2696,12 +2938,16 @@
 			  break;
 		  }
 	  }
+#ifdef PARSE_ALL
 	  s_v_ptr = save_values_bsearch(&s_v, &k);
 	  if (s_v_ptr == NULL) {
 		  n.UU.val = 0;
 	  } else {
 		  n.UU.val = 1;
 	  }
+#else
+	  n.UU.val = 1;
+#endif
 	  break;
 
   case tokcharge_balance:
@@ -2713,11 +2959,21 @@
 	  break;
 
   case toksi:
+#ifdef PARSE_ALL
     saturation_index(stringfactor(STR1, LINK), &dummy, &n.UU.val);
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toktot:
+#ifdef PARSE_ALL
     n.UU.val = total(stringfactor(STR1, LINK));
+#else
+    stringfactor(STR1, LINK);
+    n.UU.val = 1.0;
+#endif
     break;
 
   case toklog10:
@@ -2902,7 +3158,9 @@
       if (n2.UU.val != 0) {
 	n.UU.val /= n2.UU.val;
       } else {
+#ifdef PARSE_ALL
 	error_msg("Zero divide in Basic. Value set to zero.", CONTINUE);
+#endif
 	n.UU.val = 0;
       }
   }
@@ -3032,7 +3290,15 @@
 Local void checkextra(struct LOC_exec *LINK)
 {
   if (LINK->t != NULL)
+#ifdef PHREEQCI_GUI
+  {
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_EXTRA;
+#endif /* PHREEQCI_GUI */
     errormsg("Extra information on line");
+#ifdef PHREEQCI_GUI
+  }
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3076,8 +3342,21 @@
   l = findline(n, LINK);
 #endif
   l = findline(n);
+#ifdef PHREEQCI_GUI
+  if (parse_whole_program == TRUE)
+  {
+#endif /* PHREEQCI_GUI */
   if (l == NULL)
+#ifdef PHREEQCI_GUI
+  {
+      _ASSERTE(g_nIDErrPrompt == 0);
+      g_nIDErrPrompt = IDS_ERR_UNDEF_LINE;
+#endif /* PHREEQCI_GUI */
     errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+  }
+  }
+#endif /* PHREEQCI_GUI */
   return l;
 }
 
@@ -3112,11 +3391,11 @@
 			    k = k*(varbase->dims[i]);
 		    }
 		    for (i = 0; i < k; i++) {
-			    free_check_null(varbase->UU.U1.sarr[i]); 
+			    free_check_null(varbase->UU.U1.sarr[i]);
 		    }
 		    free_check_null(varbase->UU.U1.sarr);
 	    } else if (*varbase->UU.U1.sval != NULL) {
-		    *varbase->UU.U1.sval = (char*) free_check_null(*varbase->UU.U1.sval); 
+		    *varbase->UU.U1.sval = (char*) free_check_null(*varbase->UU.U1.sval);
 	    }
 
     } else {
@@ -3339,7 +3618,9 @@
 		}
 	}
 
+#ifdef PARSE_ALL
 	save_values_store(&s_v);
+#endif
 	s_v.subscripts = (int*) free_check_null(s_v.subscripts);
 }
 
@@ -3396,7 +3677,6 @@
 	if (change_surf->cell_no == 0 || change_surf->cell_no == count_cells + 1)
 		change_surf[count - 1].cell_no = -99;
 }
-
 #ifdef SKIP
 /* LINK not used */
 Local void cmdbye(struct LOC_exec *LINK)
@@ -3496,7 +3776,14 @@
 	  if (l1 == NULL)
 	    printf("Undefined line %ld in line %ld\n", lnum, l->num2);
 	  else
+#ifdef PHREEQCI_GUI
+	  {
+		  _snprintf(tok->sz_num, tok->n_sz, "%ld", l1->num2);
+#endif /* PHREEQCI_GUI */
 	    tok->UU.num = l1->num2;
+#ifdef PHREEQCI_GUI
+	  }
+#endif /* PHREEQCI_GUI */
 	  if (tok->next != NULL && tok->next->kind == tokcomma)
 	    tok = tok->next;
 	}
@@ -3893,6 +4180,10 @@
       while (LINK->t == NULL) {
 	if (stmtline == NULL || stmtline->next == NULL) {
 	  stmtline = saveline;
+#ifdef PHREEQCI_GUI
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_FOR_WO_NEXT;
+#endif /* PHREEQCI_GUI */
 	  errormsg("FOR without NEXT");
 	}
 	stmtline = stmtline->next;
@@ -3936,7 +4227,15 @@
     v = NULL;
   do {
     if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+	{
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_NEXT_WO_FOR;
+#endif /* PHREEQCI_GUI */
       errormsg("NEXT without FOR");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
     found = (boolean) (loopbase->kind == forloop &&
 	     (v == NULL || loopbase->UU.U0.vp == v));
     if (!found) {
@@ -3974,12 +4273,27 @@
     return;
   if (realexpr(LINK) != 0)
     return;
+#ifdef PHREEQCI_GUI
+  if (parse_whole_program == TRUE)
+  {
+#endif /* PHREEQCI_GUI */
   if (!skiploop(tokwhile, tokwend, LINK))
+#ifdef PHREEQCI_GUI
+  {
+    _ASSERTE(g_nIDErrPrompt == 0);
+    g_nIDErrPrompt = IDS_ERR_WHILE_WO_WEND;
+#endif /* PHREEQCI_GUI */
     errormsg("WHILE without WEND");
+#ifdef PHREEQCI_GUI
+  }
+#endif /* PHREEQCI_GUI */
   l = loopbase->next;
   free(loopbase);
   loopbase = l;
   skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+  }
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3990,9 +4304,22 @@
   looprec *l;
   boolean found;
 
+#ifdef PHREEQCI_GUI
+  if (parse_whole_program != TRUE) {
+    return;
+  }
+#endif /* PHREEQCI_GUI */
   do {
     if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+	{
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_WEND_WO_WHILE;
+#endif /* PHREEQCI_GUI */
       errormsg("WEND without WHILE");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
     found = (boolean) (loopbase->kind == whileloop);
     if (!found) {
       l = loopbase->next;
@@ -4044,9 +4371,22 @@
   looprec *l;
   boolean found;
 
+#ifdef PHREEQCI_GUI
+  if (parse_whole_program != TRUE) {
+    return;
+  }
+#endif /* PHREEQCI_GUI */
   do {
     if (loopbase == NULL)
+#ifdef PHREEQCI_GUI
+	{
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_RETURN_WO_GOSUB;
+#endif /* PHREEQCI_GUI */
       errormsg("RETURN without GOSUB");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
     found = (boolean) (loopbase->kind == gosubloop);
     if (!found) {
       l = loopbase->next;
@@ -4073,6 +4413,10 @@
     v = findvar(LINK);
     tok = LINK->t;
     LINK->t = datatok;
+#ifdef PHREEQCI_GUI
+    if (parse_whole_program == TRUE)
+    {
+#endif /* PHREEQCI_GUI */
     if (dataline == NULL) {
       dataline = linebase;
       LINK->t = dataline->txt;
@@ -4081,7 +4425,15 @@
       do {
 	while (LINK->t == NULL) {
 	  if (dataline == NULL || dataline->next == NULL)
+#ifdef PHREEQCI_GUI
+        {
+          _ASSERTE(g_nIDErrPrompt == 0);
+          g_nIDErrPrompt = IDS_ERR_OUT_OF_DATA;
+#endif /* PHREEQCI_GUI */
 	    errormsg("Out of Data");
+#ifdef PHREEQCI_GUI
+        }
+#endif /* PHREEQCI_GUI */
 	  dataline = dataline->next;
 	  LINK->t = dataline->txt;
 	}
@@ -4096,6 +4448,9 @@
       *v->UU.U1.sval = strexpr(LINK);
     } else
       *v->UU.U0.val = realexpr(LINK);
+#ifdef PHREEQCI_GUI
+    }
+#endif /* PHREEQCI_GUI */
     datatok = LINK->t;
     LINK->t = tok;
     if (!iseos(LINK))
@@ -4119,7 +4474,14 @@
     dataline = mustfindline(intexpr(LINK), LINK);
 #endif
     dataline = mustfindline(intexpr(LINK));
+#ifdef PHREEQCI_GUI
+    if (parse_whole_program == TRUE)
+    {
+#endif /* PHREEQCI_GUI */
     datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+    }
+#endif /* PHREEQCI_GUI */
   }
 }
 
@@ -4180,7 +4542,15 @@
     v = LINK->t->UU.vp;
     LINK->t = LINK->t->next;
     if (v->numdims != 0)
+#ifdef PHREEQCI_GUI
+	{
+	  _ASSERTE(g_nIDErrPrompt == 0);
+	  g_nIDErrPrompt = IDS_ERR_ARRAY_ALREADY;
+#endif /* PHREEQCI_GUI */
       errormsg("Array already dimensioned");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
     j = 1;
     i = 0;
     require(toklp, LINK);
@@ -4255,6 +4625,13 @@
 	V.t = stmttok;
 	if (V.t != NULL) {
 	  V.t = V.t->next;
+#ifdef PHREEQCI_GUI
+	if (WaitForSingleObject(s_hInfiniteLoop , 0) == WAIT_OBJECT_0)
+	{
+		g_nIDErrPrompt = IDS_ERR_INFINITE_LOOP;
+		errormsg("Possible infinite loop");
+	}
+#endif /* PHREEQCI_GUI */
 	  switch (stmttok->kind) {
 
 	  case tokrem:
@@ -4343,7 +4720,13 @@
 #endif
 
 	  case tokinput:
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_INPUT_NOTLEGAL;
+	    errormsg("Basic command INPUT is not a legal command in PHREEQC.");
+#else /* PHREEQCI_GUI */
 	    error_msg("Basic command INPUT is not a legal command in PHREEQC.", STOP);
+#endif /* PHREEQCI_GUI */
 #ifdef SKIP
 	    cmdinput(&V);
 #endif
@@ -4422,6 +4805,10 @@
 	    break;
 
 	  default:
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_ILLEGAL;
+#endif /* PHREEQCI_GUI */
 	    errormsg("Illegal command");
 	    break;
 	  }
@@ -4510,8 +4897,13 @@
       }
     }
     if (stmtline != NULL) {
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nErrLineNumber == 0);
+		g_nErrLineNumber = stmtline->num;
+#else /* PHREEQCI_GUI */
 	    sprintf(error_string, " in line %ld", stmtline->num);
 	    error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
     }
 #ifdef SKIP
       printf(" in %ld", stmtline->num);
@@ -4529,7 +4921,7 @@
 			k = k*(varbase->dims[i]);
 		}
 		for (i = 0; i < k; i++) {
-			free_check_null(varbase->UU.U1.sarr[i]); 
+			free_check_null(varbase->UU.U1.sarr[i]);
 		}
 		varbase->UU.U1.sarr = (char **) free_check_null(varbase->UU.U1.sarr);
 	}
