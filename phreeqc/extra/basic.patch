--- basic.c	2010-01-13 16:16:44.071302000 -0700
+++ basic1.c	2010-01-13 16:15:41.322908400 -0700
@@ -3,20 +3,30 @@
 
 #if !defined(PHREEQC_CLASS)
 #define EXTERNAL extern
-#include "global.h"
+#include "../src/global.h"
 #else
 typedef unsigned char boolean;
-#include "Phreeqc.h"
+#include "../src/Phreeqc.h"
 #endif
 
-#include "phqalloc.h"
-#include "output.h"
-#include "phrqproto.h"
-#include "p2c.h"
+#include "../src/phqalloc.h"
+#include "../src/output.h"
+#include "../src/phrqproto.h"
+#include "../src/p2c.h"
 #if !defined(PHREEQC_CLASS)
 static char const svnid[] = "$Id: basic.c 3869 2009-12-07 21:33:07Z dlpark $";
 
 int n_user_punch_index;
+
+#ifdef PHREEQCI_GUI
+#define cmd_free        cmd_free_1
+#define cmd_initialize  cmd_initialize_1
+#define basic_renumber  basic_renumber_1
+#define basic_run       basic_run_1
+#define basic_compile   basic_compile_1
+#define basic_main      basic_main_1
+#endif /* PHREEQCI_GUI */
+
 #ifdef PHREEQ98
 void GridChar(char *s, char *a);
 extern int colnr, rownr;
@@ -24,7 +34,7 @@
 
 static int sget_logical_line(char **ptr, int *l, char *return_line);
 
-#include "basic.h"
+#include "../src/basic.h"
 
 Static Char *inbuf;
 Static linerec *linebase;
@@ -35,12 +45,27 @@
 Static tokenrec *stmttok, *datatok, *buf;
 Static boolean exitflag;
 
+#ifdef PHREEQCI_GUI
+Static int parse_whole_program;
+static HANDLE s_hInfiniteLoop = 0;
+UINT g_nIDErrPrompt;
+int g_nErrLineNumber;
+#include "../../resource.h"
+#endif /* PHREEQCI_GUI */
+
 Static int free_dim_stringvar(struct varrec *varbase);
 extern long EXCP_LINE;
 Static void parseinput(tokenrec ** buf);
 Static void exec(void);
 Static void disposetokens(tokenrec ** tok);
 
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+				  int parse_whole_program_flag);
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+			  int parse_whole_program_flag, HANDLE hInfiniteLoop);
+#endif /* PHREEQCI_GUI */
+
 /*$if not checking$
    $range off$
 $end$*/
@@ -240,7 +265,6 @@
  */
 
 	hdestroy_multi(command_hash_table);
-	command_hash_table = NULL;
 	return;
 }
 
@@ -253,11 +277,22 @@
 	return 0;
 }
 #endif
+#ifdef PHREEQCI_GUI
+int
+basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+			  int parse_whole_program_flag)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(P_escapecode == 0);
+	_ASSERTE(g_nIDErrPrompt == 0);
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	/*
 	if (svnid == NULL)
 		fprintf(stderr, " ");
@@ -271,6 +306,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	do
 	{
@@ -299,13 +337,21 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			putchar('\n');
+#endif /* PHREEQCI_GUI */
 		}
 		ENDTRY(try2);
 	}
@@ -315,6 +361,9 @@
 	*lnbase = (void *) linebase;
 	*vbase = (void *) varbase;
 	*lpbase = (void *) loopbase;
+#ifndef PHREEQCI_GUI
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
@@ -396,11 +445,22 @@
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+int
+basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+		  int parse_whole_program_flag, HANDLE hInfiniteLoop)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_run(char *commands, void *lnbase, void *vbase, void *lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(s_hInfiniteLoop == 0);
+	s_hInfiniteLoop = hInfiniteLoop;
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	PASCAL_MAIN(0, NULL);
 	inbuf = (char *) PHRQ_calloc(max_line, sizeof(char));
 	if (inbuf == NULL)
@@ -409,6 +469,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	linebase = (linerec *) lnbase;
 	varbase = (varrec *) vbase;
@@ -439,9 +502,13 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
@@ -453,9 +520,25 @@
 
 	/*  exit(EXIT_SUCCESS); */
 	free(inbuf);
+#ifdef PHREEQCI_GUI
+	s_hInfiniteLoop = 0;
+#else /* PHREEQCI_GUI */
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+void
+basic_free(void *lnbase, void *vbase, void *lpbase)
+{
+	basic_run("new; quit", lnbase, vbase, lpbase, FALSE, s_hInfiniteLoop);
+	lnbase = NULL;
+	vbase = NULL;
+	lpbase = NULL;
+}
+#endif /* PHREEQCI_GUI */
+
 int CLASS_QUALIFIER
 basic_main(char *commands)
 {								/*main */
@@ -751,6 +834,10 @@
 				tptr->next = t;
 			tptr = t;
 			t->next = NULL;
+#ifdef PHREEQCI_GUI
+			t->n_sz = 0;
+			t->sz_num = 0;
+#endif
 			switch (ch)
 			{
 
@@ -1028,9 +1115,9 @@
 							t->kind = tokto;
 						else if (!strcmp(token, "step"))
 							t->kind = tokstep;
-						/*
-						 *   dlp: added functions
-						 */
+/*
+ *   dlp: added functions
+ */
 						else if (!strcmp(token, "tc"))
 							t->kind = toktc;
 						else if (!strcmp(token, "tk"))
@@ -1207,6 +1294,25 @@
 						i++;
 						break;
 					}
+#ifdef PHREEQCI_GUI
+					_ASSERTE(t->n_sz == 0);
+					_ASSERTE(t->sz_num == NULL);
+					t->n_sz = max(23, ptr - &inbuf[i - 1]);
+					t->sz_num =
+						(char *) PHRQ_malloc((t->n_sz + 1) * sizeof(char));
+					if (t->sz_num == NULL)
+						malloc_error();
+					if (ptr > &inbuf[i - 1])
+					{
+						strncpy(t->sz_num, &inbuf[i - 1],
+								(ptr - &inbuf[i - 1]));
+						t->sz_num[ptr - &inbuf[i - 1]] = '\0';
+					}
+					else
+					{
+						t->sz_num[0] = '\0';
+					}
+#endif /* PHREEQCI_GUI */
 					i += (int) (ptr - &inbuf[i - 1]);
 				}
 				else
@@ -1843,6 +1949,18 @@
 	while (*tok != NULL)
 	{
 		tok1 = (*tok)->next;
+#ifdef PHREEQCI_GUI
+		if ((*tok)->kind == (long) toknum)
+		{
+			free((*tok)->sz_num);
+		}
+#ifdef _DEBUG
+		else
+		{
+			_ASSERTE((*tok)->sz_num == NULL);
+		}
+#endif /* _DEBUG */
+#endif /* PHREEQCI_GUI */
 		if ((*tok)->kind == (long) tokrem || (*tok)->kind == (long) tokstr)
 		{
 			(*tok)->UU.sp = (char *) free_check_null((*tok)->UU.sp);
@@ -1916,7 +2034,12 @@
 #ifdef SKIP
 	printf("\007%s", s);
 #endif
+#ifdef PHREEQCI_GUI
+	/* set g_nIDErrPrompt before calling errormsg see snerr */
+	_ASSERTE(g_nIDErrPrompt != 0);
+#else /* PHREEQCI_GUI */
 	error_msg(s, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	_Escape(42);
 }
 
@@ -1926,6 +2049,10 @@
 {
   char str[MAX_LENGTH];
   strcpy(str, "Syntax_error ");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_SYNTAX;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -1935,6 +2062,10 @@
 {
   char str[MAX_LENGTH];
   strcpy(str, "Type mismatch error");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_MISMATCH;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -1942,6 +2073,10 @@
 Static void CLASS_QUALIFIER
 badsubscr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_BAD_SUBSCRIPT;
+#endif /* PHREEQCI_GUI */
 	errormsg("Bad subscript");
 }
 
@@ -2173,7 +2308,9 @@
 	long i, j, m;
 	tokenrec *tok, *tok1;
 	Char *s;
+#ifdef PARSE_ALL
 	LDBLE dummy;
+#endif
 	int i_rate;
 	union
 	{
@@ -2181,7 +2318,9 @@
 		Char *c;
 	} trick;
 	struct save_values s_v, *s_v_ptr;
+#ifdef PARSE_ALL
 	int k;
+#endif
 	LDBLE TEMP;
 	Char STR1[256], STR2[256];
 	char *elt_name, *surface_name, *mytemplate, *name;
@@ -2356,15 +2495,24 @@
 
 	case tokparm:
 		i_rate = intfactor(LINK);
+#ifdef PARSE_ALL
 		if (i_rate > count_rate_p)
 		{
 			errormsg("Parameter subscript out of range.");
 		}
 		n.UU.val = rate_p[i_rate - 1];
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokact:
+#ifdef PARSE_ALL
 		n.UU.val = activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokgamma:
@@ -2400,7 +2548,11 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = diff_layer_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksurf:
@@ -2416,31 +2568,65 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = surf_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokequi:
+#ifdef PARSE_ALL
 		n.UU.val = equi_phase(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokkin:
+#ifdef PARSE_ALL
 		n.UU.val = kinetics_moles(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokgas:
+#ifdef PARSE_ALL
 		n.UU.val = find_gas_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toks_s:
+#ifdef PARSE_ALL
 		n.UU.val = find_s_s_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc1:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc1(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc2:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc2(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmu:
@@ -2463,15 +2649,30 @@
 		break;
 
 	case toklk_species:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_s(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_named:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_n(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_phase:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_p(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toksum_species:
@@ -2487,7 +2688,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_species(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_gas:
@@ -2503,7 +2708,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_gases(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_s_s:
@@ -2519,14 +2728,22 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_s_s(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokcalc_value:
 		require(toklp, LINK);
 		name = stringfactor(STR1, LINK);
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = get_calculate_value(name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokdescription:
@@ -2752,19 +2969,39 @@
 		break;
 
 	case tokmol:
+#ifdef PARSE_ALL
 		n.UU.val = molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokla:
+#ifdef PARSE_ALL
 		n.UU.val = log_activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toklm:
+#ifdef PARSE_ALL
 		n.UU.val = log_molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksr:
+#ifdef PARSE_ALL
 		n.UU.val = saturation_ratio(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokstep_no:
@@ -2790,6 +3027,7 @@
 		}
 		break;
 
+#ifdef PARSE_ALL
 	case tokcell_no:
 		if (state == TRANSPORT)
 		{
@@ -2819,6 +3057,11 @@
 			}
 		}
 		break;
+#else
+	case tokcell_no:
+		n.UU.val = 1;
+		break;
+#endif
 
 	case toksim_no:
 		n.UU.val = simulation;
@@ -2877,10 +3120,18 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
+#else
+		s_v_ptr = NULL;
+#endif
 		if (s_v_ptr == NULL)
 		{
+#ifdef PARSE_ALL
 			n.UU.val = 0;
+#else
+			n.UU.val = 1;
+#endif
 		}
 		else
 		{
@@ -2941,6 +3192,7 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
 		if (s_v_ptr == NULL)
 		{
@@ -2950,6 +3202,9 @@
 		{
 			n.UU.val = 1;
 		}
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokcharge_balance:
@@ -2961,11 +3216,21 @@
 		break;
 
 	case toksi:
+#ifdef PARSE_ALL
 		saturation_index(stringfactor(STR1, LINK), &dummy, &n.UU.val);
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toktot:
+#ifdef PARSE_ALL
 		n.UU.val = total(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokporevolume:
@@ -3189,8 +3454,10 @@
 		}
 		else
 		{
+#ifdef PARSE_ALL
 			sprintf(error_string, "Zero divide in BASIC line\n %ld %s.\nValue set to zero.", stmtline->num, stmtline->inbuf);
 			warning_msg(error_string, CONTINUE);
+#endif
 			n.UU.val = 0;
 		}
 	}
@@ -3360,7 +3627,15 @@
 checkextra(struct LOC_exec *LINK)
 {
 	if (LINK->t != NULL)
+#ifdef PHREEQCI_GUI
+	{
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_EXTRA;
+#endif /* PHREEQCI_GUI */
 		errormsg("Extra information on line");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3410,10 +3685,21 @@
 	l = findline(n, LINK);
 #endif
 	l = findline(n);
-	if (l == NULL) {
-		sprintf(error_string, "Undefined line %ld", n);
-		errormsg(error_string);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (l == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_UNDEF_LINE;
+#endif /* PHREEQCI_GUI */
+			errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+		}
 	}
+#endif /* PHREEQCI_GUI */
 	return l;
 }
 
@@ -3726,7 +4012,9 @@
 		}
 	}
 
+#ifdef PARSE_ALL
 	save_values_store(&s_v);
+#endif
 	s_v.subscripts = (int *) free_check_null(s_v.subscripts);
 }
 
@@ -3909,7 +4197,14 @@
 						printf("Undefined line %ld in line %ld\n", lnum,
 							   l->num2);
 					else
+#ifdef PHREEQCI_GUI
+					{
+						_snprintf(tok->sz_num, tok->n_sz, "%ld", l1->num2);
+#endif /* PHREEQCI_GUI */
 						tok->UU.num = l1->num2;
+#ifdef PHREEQCI_GUI
+					}
+#endif /* PHREEQCI_GUI */
 					if (tok->next != NULL && tok->next->kind == tokcomma)
 						tok = tok->next;
 				}
@@ -4385,6 +4680,10 @@
 				if (stmtline == NULL || stmtline->next == NULL)
 				{
 					stmtline = saveline;
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_FOR_WO_NEXT;
+#endif /* PHREEQCI_GUI */
 					errormsg("FOR without NEXT");
 				}
 				stmtline = stmtline->next;
@@ -4434,7 +4733,15 @@
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_NEXT_WO_FOR;
+#endif /* PHREEQCI_GUI */
 			errormsg("NEXT without FOR");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == forloop &&
 						   (v == NULL || loopbase->UU.U0.vp == v));
 		if (!found)
@@ -4479,12 +4786,27 @@
 		return;
 	if (realexpr(LINK) != 0)
 		return;
-	if (!skiploop(tokwhile, tokwend, LINK))
-		errormsg("WHILE without WEND");
-	l = loopbase->next;
-	free(loopbase);
-	loopbase = l;
-	skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (!skiploop(tokwhile, tokwend, LINK))
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WHILE_WO_WEND;
+#endif /* PHREEQCI_GUI */
+			errormsg("WHILE without WEND");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
+		l = loopbase->next;
+		free(loopbase);
+		loopbase = l;
+		skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -4496,10 +4818,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WEND_WO_WHILE;
+#endif /* PHREEQCI_GUI */
 			errormsg("WEND without WHILE");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == whileloop);
 		if (!found)
 		{
@@ -4559,10 +4895,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_RETURN_WO_GOSUB;
+#endif /* PHREEQCI_GUI */
 			errormsg("RETURN without GOSUB");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == gosubloop);
 		if (!found)
 		{
@@ -4593,37 +4943,52 @@
 		v = findvar(LINK);
 		tok = LINK->t;
 		LINK->t = datatok;
-		if (dataline == NULL)
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
 		{
-			dataline = linebase;
-			LINK->t = dataline->txt;
-		}
-		if (LINK->t == NULL || LINK->t->kind != tokcomma)
-		{
-			do
+#endif /* PHREEQCI_GUI */
+			if (dataline == NULL)
+			{
+				dataline = linebase;
+				LINK->t = dataline->txt;
+			}
+			if (LINK->t == NULL || LINK->t->kind != tokcomma)
 			{
-				while (LINK->t == NULL)
+				do
 				{
-					if (dataline == NULL || dataline->next == NULL)
-						errormsg("Out of Data");
-					dataline = dataline->next;
-					LINK->t = dataline->txt;
+					while (LINK->t == NULL)
+					{
+						if (dataline == NULL || dataline->next == NULL)
+#ifdef PHREEQCI_GUI
+						{
+							_ASSERTE(g_nIDErrPrompt == 0);
+							g_nIDErrPrompt = IDS_ERR_OUT_OF_DATA;
+#endif /* PHREEQCI_GUI */
+							errormsg("Out of Data");
+#ifdef PHREEQCI_GUI
+						}
+#endif /* PHREEQCI_GUI */
+						dataline = dataline->next;
+						LINK->t = dataline->txt;
+					}
+					found = (boolean) (LINK->t->kind == tokdata);
+					LINK->t = LINK->t->next;
 				}
-				found = (boolean) (LINK->t->kind == tokdata);
+				while (!found || iseos(LINK));
+			}
+			else
 				LINK->t = LINK->t->next;
+			if (v->stringvar)
+			{
+				if (*v->UU.U1.sval != NULL)
+					*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
+				*v->UU.U1.sval = strexpr(LINK);
 			}
-			while (!found || iseos(LINK));
-		}
-		else
-			LINK->t = LINK->t->next;
-		if (v->stringvar)
-		{
-			if (*v->UU.U1.sval != NULL)
-				*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
-			*v->UU.U1.sval = strexpr(LINK);
+			else
+				*v->UU.U0.val = realexpr(LINK);
+#ifdef PHREEQCI_GUI
 		}
-		else
-			*v->UU.U0.val = realexpr(LINK);
+#endif /* PHREEQCI_GUI */
 		datatok = LINK->t;
 		LINK->t = tok;
 		if (!iseos(LINK))
@@ -4651,7 +5016,14 @@
 		dataline = mustfindline(intexpr(LINK), LINK);
 #endif
 		dataline = mustfindline(intexpr(LINK));
-		datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
+		{
+#endif /* PHREEQCI_GUI */
+			datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 	}
 }
 
@@ -4721,7 +5093,15 @@
 		v = LINK->t->UU.vp;
 		LINK->t = LINK->t->next;
 		if (v->numdims != 0)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_ARRAY_ALREADY;
+#endif /* PHREEQCI_GUI */
 			errormsg("Array already dimensioned before");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		j = 1;
 		i = 0;
 		require(toklp, LINK);
@@ -4801,6 +5181,13 @@
 			if (V.t != NULL)
 			{
 				V.t = V.t->next;
+#ifdef PHREEQCI_GUI
+				if (WaitForSingleObject(s_hInfiniteLoop, 0) == WAIT_OBJECT_0)
+				{
+					g_nIDErrPrompt = IDS_ERR_INFINITE_LOOP;
+					errormsg("Possible infinite loop");
+				}
+#endif /* PHREEQCI_GUI */
 				switch (stmttok->kind)
 				{
 
@@ -4890,9 +5277,16 @@
 #endif
 
 				case tokinput:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_INPUT_NOTLEGAL;
+					errormsg
+						("Basic command INPUT is not a legal command in PHREEQC.");
+#else /* PHREEQCI_GUI */
 					error_msg
 						("Basic command INPUT is not a legal command in PHREEQC.",
 						 STOP);
+#endif /* PHREEQCI_GUI */
 #ifdef SKIP
 					cmdinput(&V);
 #endif
@@ -4971,6 +5365,10 @@
 					break;
 
 				default:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_ILLEGAL;
+#endif /* PHREEQCI_GUI */
 					errormsg("Illegal command");
 					break;
 				}
@@ -5070,8 +5468,13 @@
 	}
 	if (stmtline != NULL)
 	{
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nErrLineNumber == 0);
+		g_nErrLineNumber = stmtline->num;
+#else /* PHREEQCI_GUI */
 		sprintf(error_string, " in BASIC line\n %ld %s", stmtline->num, stmtline->inbuf);
 		error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	}
 #ifdef SKIP
 	printf(" in %ld", stmtline->num);
