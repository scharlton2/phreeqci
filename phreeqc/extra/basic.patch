--- basic.c	2009-03-02 16:53:17.787666900 -0700
+++ basic1.c	2009-03-02 16:32:59.998660800 -0700
@@ -5,18 +5,28 @@
 static char const svnid[] = "$Id: basic.c 2970 2008-06-26 16:43:51Z dlpark $";
 
 #define EXTERNAL extern
-#include "global.h"
-#include "phqalloc.h"
-#include "output.h"
-#include "phrqproto.h"
+#include "../src/global.h"
+#include "../src/phqalloc.h"
+#include "../src/output.h"
+#include "../src/phrqproto.h"
 
 int n_user_punch_index;
+
+#ifdef PHREEQCI_GUI
+#define cmd_free        cmd_free_1
+#define cmd_initialize  cmd_initialize_1
+#define basic_renumber  basic_renumber_1
+#define basic_run       basic_run_1
+#define basic_compile   basic_compile_1
+#define basic_main      basic_main_1
+#endif /* PHREEQCI_GUI */
+
 #ifdef PHREEQ98
 void GridChar(char *s, char *a);
 extern int colnr, rownr;
 #endif
 
-#include "p2c.h"
+#include "../src/p2c.h"
 
 static int sget_logical_line(char **ptr, int *l, char *return_line);
 
@@ -186,6 +196,10 @@
 		Char *sp;
 		Char snch;
 	} UU;
+#ifdef PHREEQCI_GUI
+	size_t n_sz;
+	Char *sz_num;
+#endif							/* PHREEQCI_GUI */
 } tokenrec;
 
 typedef struct linerec
@@ -253,12 +267,27 @@
 Static tokenrec *stmttok, *datatok, *buf;
 Static boolean exitflag;
 
+#ifdef PHREEQCI_GUI
+Static int parse_whole_program;
+static HANDLE s_hInfiniteLoop = 0;
+UINT g_nIDErrPrompt;
+int g_nErrLineNumber;
+#include "../../resource.h"
+#endif /* PHREEQCI_GUI */
+
 Static int free_dim_stringvar(struct varrec *varbase);
 extern long EXCP_LINE;
 Static void parseinput(tokenrec ** buf);
 Static void exec(void);
 Static void disposetokens(tokenrec ** tok);
 
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+				  int parse_whole_program_flag);
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+			  int parse_whole_program_flag, HANDLE hInfiniteLoop);
+#endif /* PHREEQCI_GUI */
+
 /*$if not checking$
    $range off$
 $end$*/
@@ -431,7 +460,6 @@
  */
 
 	hdestroy_multi(command_hash_table);
-	command_hash_table = NULL;
 	return;
 }
 
@@ -444,11 +472,22 @@
 	return 0;
 }
 #endif
+#ifdef PHREEQCI_GUI
+int
+basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+			  int parse_whole_program_flag)
+#else /* PHREEQCI_GUI */
 int
 basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(P_escapecode == 0);
+	_ASSERTE(g_nIDErrPrompt == 0);
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	if (svnid == NULL)
 		fprintf(stderr, " ");
 
@@ -460,6 +499,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	do
 	{
@@ -488,13 +530,21 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			putchar('\n');
+#endif /* PHREEQCI_GUI */
 		}
 		ENDTRY(try2);
 	}
@@ -504,6 +554,9 @@
 	*lnbase = (void *) linebase;
 	*vbase = (void *) varbase;
 	*lpbase = (void *) loopbase;
+#ifndef PHREEQCI_GUI
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
@@ -585,11 +638,22 @@
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+int
+basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+		  int parse_whole_program_flag, HANDLE hInfiniteLoop)
+#else /* PHREEQCI_GUI */
 int
 basic_run(char *commands, void *lnbase, void *vbase, void *lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(s_hInfiniteLoop == 0);
+	s_hInfiniteLoop = hInfiniteLoop;
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	PASCAL_MAIN(0, NULL);
 	inbuf = (char *) PHRQ_calloc(max_line, sizeof(char));
 	if (inbuf == NULL)
@@ -598,6 +662,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	linebase = (linerec *) lnbase;
 	varbase = (varrec *) vbase;
@@ -628,9 +695,13 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
@@ -642,9 +713,25 @@
 
 	/*  exit(EXIT_SUCCESS); */
 	free(inbuf);
+#ifdef PHREEQCI_GUI
+	s_hInfiniteLoop = 0;
+#else /* PHREEQCI_GUI */
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+void
+basic_free(void *lnbase, void *vbase, void *lpbase)
+{
+	basic_run("new; quit", lnbase, vbase, lpbase, FALSE, s_hInfiniteLoop);
+	lnbase = NULL;
+	vbase = NULL;
+	lpbase = NULL;
+}
+#endif /* PHREEQCI_GUI */
+
 int
 basic_main(char *commands)
 {								/*main */
@@ -1214,9 +1301,9 @@
 							t->kind = tokto;
 						else if (!strcmp(token, "step"))
 							t->kind = tokstep;
-						/*
-						 *   dlp: added functions
-						 */
+/*
+ *   dlp: added functions
+ */
 						else if (!strcmp(token, "tc"))
 							t->kind = toktc;
 						else if (!strcmp(token, "tk"))
@@ -1393,6 +1480,25 @@
 						i++;
 						break;
 					}
+#ifdef PHREEQCI_GUI
+					_ASSERTE(t->n_sz == 0);
+					_ASSERTE(t->sz_num == NULL);
+					t->n_sz = max(23, ptr - &inbuf[i - 1]);
+					t->sz_num =
+						(char *) PHRQ_malloc((t->n_sz + 1) * sizeof(char));
+					if (t->sz_num == NULL)
+						malloc_error();
+					if (ptr > &inbuf[i - 1])
+					{
+						strncpy(t->sz_num, &inbuf[i - 1],
+								(ptr - &inbuf[i - 1]));
+						t->sz_num[ptr - &inbuf[i - 1]] = '\0';
+					}
+					else
+					{
+						t->sz_num[0] = '\0';
+					}
+#endif /* PHREEQCI_GUI */
 					i += (int) (ptr - &inbuf[i - 1]);
 				}
 				else
@@ -2016,6 +2122,18 @@
 	while (*tok != NULL)
 	{
 		tok1 = (*tok)->next;
+#ifdef PHREEQCI_GUI
+		if ((*tok)->kind == (long) toknum)
+		{
+			free((*tok)->sz_num);
+		}
+#ifdef _DEBUG
+		else
+		{
+			_ASSERTE((*tok)->sz_num == NULL);
+		}
+#endif /* _DEBUG */
+#endif /* PHREEQCI_GUI */
 		if ((*tok)->kind == (long) tokrem || (*tok)->kind == (long) tokstr)
 		{
 			(*tok)->UU.sp = (char *) free_check_null((*tok)->UU.sp);
@@ -2088,7 +2206,12 @@
 #ifdef SKIP
 	printf("\007%s", s);
 #endif
+#ifdef PHREEQCI_GUI
+	/* set g_nIDErrPrompt before calling errormsg see snerr */
+	_ASSERTE(g_nIDErrPrompt != 0);
+#else /* PHREEQCI_GUI */
 	error_msg(s, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	_Escape(42);
 }
 
@@ -2096,6 +2219,10 @@
 Static void
 snerr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_SYNTAX;
+#endif /* PHREEQCI_GUI */
 	errormsg("Syntax error");
 }
 
@@ -2103,6 +2230,10 @@
 Static void
 tmerr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_MISMATCH;
+#endif /* PHREEQCI_GUI */
 	errormsg("Type mismatch error");
 }
 
@@ -2110,6 +2241,10 @@
 Static void
 badsubscr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_BAD_SUBSCRIPT;
+#endif /* PHREEQCI_GUI */
 	errormsg("Bad subscript");
 }
 
@@ -2338,7 +2473,9 @@
 	long i, j, m;
 	tokenrec *tok, *tok1;
 	Char *s;
+#ifdef PARSE_ALL
 	LDBLE dummy;
+#endif
 	int i_rate;
 	union
 	{
@@ -2346,7 +2483,9 @@
 		Char *c;
 	} trick;
 	struct save_values s_v, *s_v_ptr;
+#ifdef PARSE_ALL
 	int k;
+#endif
 	LDBLE TEMP;
 	Char STR1[256], STR2[256];
 	char *elt_name, *surface_name, *mytemplate, *name;
@@ -2521,15 +2660,24 @@
 
 	case tokparm:
 		i_rate = intfactor(LINK);
+#ifdef PARSE_ALL
 		if (i_rate > count_rate_p)
 		{
 			errormsg("Parameter subscript out of range.");
 		}
 		n.UU.val = rate_p[i_rate - 1];
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokact:
+#ifdef PARSE_ALL
 		n.UU.val = activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokgamma:
@@ -2565,7 +2713,11 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = diff_layer_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksurf:
@@ -2581,31 +2733,65 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = surf_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokequi:
+#ifdef PARSE_ALL
 		n.UU.val = equi_phase(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokkin:
+#ifdef PARSE_ALL
 		n.UU.val = kinetics_moles(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokgas:
+#ifdef PARSE_ALL
 		n.UU.val = find_gas_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toks_s:
+#ifdef PARSE_ALL
 		n.UU.val = find_s_s_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc1:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc1(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc2:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc2(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmu:
@@ -2628,15 +2814,30 @@
 		break;
 
 	case toklk_species:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_s(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_named:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_n(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_phase:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_p(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toksum_species:
@@ -2652,7 +2853,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_species(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_gas:
@@ -2668,7 +2873,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_gases(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_s_s:
@@ -2684,14 +2893,22 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_s_s(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokcalc_value:
 		require(toklp, LINK);
 		name = stringfactor(STR1, LINK);
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = get_calculate_value(name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokdescription:
@@ -2917,19 +3134,39 @@
 		break;
 
 	case tokmol:
+#ifdef PARSE_ALL
 		n.UU.val = molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokla:
+#ifdef PARSE_ALL
 		n.UU.val = log_activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toklm:
+#ifdef PARSE_ALL
 		n.UU.val = log_molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksr:
+#ifdef PARSE_ALL
 		n.UU.val = saturation_ratio(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokstep_no:
@@ -2955,6 +3192,7 @@
 		}
 		break;
 
+#ifdef PARSE_ALL
 	case tokcell_no:
 		if (state == TRANSPORT)
 		{
@@ -2984,6 +3222,11 @@
 			}
 		}
 		break;
+#else
+	case tokcell_no:
+		n.UU.val = 1;
+		break;
+#endif
 
 	case toksim_no:
 		n.UU.val = simulation;
@@ -3042,10 +3285,18 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
+#else
+		s_v_ptr = NULL;
+#endif
 		if (s_v_ptr == NULL)
 		{
+#ifdef PARSE_ALL
 			n.UU.val = 0;
+#else
+			n.UU.val = 1;
+#endif
 		}
 		else
 		{
@@ -3106,6 +3357,7 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
 		if (s_v_ptr == NULL)
 		{
@@ -3115,6 +3367,9 @@
 		{
 			n.UU.val = 1;
 		}
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokcharge_balance:
@@ -3126,11 +3381,21 @@
 		break;
 
 	case toksi:
+#ifdef PARSE_ALL
 		saturation_index(stringfactor(STR1, LINK), &dummy, &n.UU.val);
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toktot:
+#ifdef PARSE_ALL
 		n.UU.val = total(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokporevolume:
@@ -3348,7 +3613,9 @@
 		}
 		else
 		{
+#ifdef PARSE_ALL
 			error_msg("Zero divide in Basic. Value set to zero.", CONTINUE);
+#endif
 			n.UU.val = 0;
 		}
 	}
@@ -3518,7 +3785,15 @@
 checkextra(struct LOC_exec *LINK)
 {
 	if (LINK->t != NULL)
+#ifdef PHREEQCI_GUI
+	{
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_EXTRA;
+#endif /* PHREEQCI_GUI */
 		errormsg("Extra information on line");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3566,8 +3841,21 @@
 	l = findline(n, LINK);
 #endif
 	l = findline(n);
-	if (l == NULL)
-		errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (l == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_UNDEF_LINE;
+#endif /* PHREEQCI_GUI */
+			errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+		}
+	}
+#endif /* PHREEQCI_GUI */
 	return l;
 }
 
@@ -3880,7 +4168,9 @@
 		}
 	}
 
+#ifdef PARSE_ALL
 	save_values_store(&s_v);
+#endif
 	s_v.subscripts = (int *) free_check_null(s_v.subscripts);
 }
 
@@ -3896,8 +4186,7 @@
 	/* get cell_no */
 	j = intexpr(LINK);
 	require(tokrp, LINK);
-	if (j > 0 && j <= count_cells * (1 + stag_data->count_stag) + 1
-		&& j != count_cells + 1)
+	if (j != 0 && j != count_cells + 1)
 		cell_data[j - 1].por = TEMP;
 }
 
@@ -3913,8 +4202,8 @@
 
 	change_surf_count += 1;
 	count = change_surf_count;
-	if (change_surf[count - 1].next == FALSE)
-		change_surf = change_surf_alloc(count + 1);
+	if (count > 1 && change_surf[count - 1].next == FALSE)
+		change_surf = change_surf_alloc(count);
 
 	require(toklp, LINK);
 	/* get surface component name (change affects all comps of the same charge structure) */
@@ -4062,7 +4351,14 @@
 						printf("Undefined line %ld in line %ld\n", lnum,
 							   l->num2);
 					else
+#ifdef PHREEQCI_GUI
+					{
+						_snprintf(tok->sz_num, tok->n_sz, "%ld", l1->num2);
+#endif /* PHREEQCI_GUI */
 						tok->UU.num = l1->num2;
+#ifdef PHREEQCI_GUI
+					}
+#endif /* PHREEQCI_GUI */
 					if (tok->next != NULL && tok->next->kind == tokcomma)
 						tok = tok->next;
 				}
@@ -4538,6 +4834,10 @@
 				if (stmtline == NULL || stmtline->next == NULL)
 				{
 					stmtline = saveline;
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_FOR_WO_NEXT;
+#endif /* PHREEQCI_GUI */
 					errormsg("FOR without NEXT");
 				}
 				stmtline = stmtline->next;
@@ -4587,7 +4887,15 @@
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_NEXT_WO_FOR;
+#endif /* PHREEQCI_GUI */
 			errormsg("NEXT without FOR");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == forloop &&
 						   (v == NULL || loopbase->UU.U0.vp == v));
 		if (!found)
@@ -4632,12 +4940,27 @@
 		return;
 	if (realexpr(LINK) != 0)
 		return;
-	if (!skiploop(tokwhile, tokwend, LINK))
-		errormsg("WHILE without WEND");
-	l = loopbase->next;
-	free(loopbase);
-	loopbase = l;
-	skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (!skiploop(tokwhile, tokwend, LINK))
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WHILE_WO_WEND;
+#endif /* PHREEQCI_GUI */
+			errormsg("WHILE without WEND");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
+		l = loopbase->next;
+		free(loopbase);
+		loopbase = l;
+		skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -4649,10 +4972,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WEND_WO_WHILE;
+#endif /* PHREEQCI_GUI */
 			errormsg("WEND without WHILE");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == whileloop);
 		if (!found)
 		{
@@ -4712,10 +5049,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_RETURN_WO_GOSUB;
+#endif /* PHREEQCI_GUI */
 			errormsg("RETURN without GOSUB");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == gosubloop);
 		if (!found)
 		{
@@ -4746,37 +5097,52 @@
 		v = findvar(LINK);
 		tok = LINK->t;
 		LINK->t = datatok;
-		if (dataline == NULL)
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
 		{
-			dataline = linebase;
-			LINK->t = dataline->txt;
-		}
-		if (LINK->t == NULL || LINK->t->kind != tokcomma)
-		{
-			do
+#endif /* PHREEQCI_GUI */
+			if (dataline == NULL)
+			{
+				dataline = linebase;
+				LINK->t = dataline->txt;
+			}
+			if (LINK->t == NULL || LINK->t->kind != tokcomma)
 			{
-				while (LINK->t == NULL)
+				do
 				{
-					if (dataline == NULL || dataline->next == NULL)
-						errormsg("Out of Data");
-					dataline = dataline->next;
-					LINK->t = dataline->txt;
+					while (LINK->t == NULL)
+					{
+						if (dataline == NULL || dataline->next == NULL)
+#ifdef PHREEQCI_GUI
+						{
+							_ASSERTE(g_nIDErrPrompt == 0);
+							g_nIDErrPrompt = IDS_ERR_OUT_OF_DATA;
+#endif /* PHREEQCI_GUI */
+							errormsg("Out of Data");
+#ifdef PHREEQCI_GUI
+						}
+#endif /* PHREEQCI_GUI */
+						dataline = dataline->next;
+						LINK->t = dataline->txt;
+					}
+					found = (boolean) (LINK->t->kind == tokdata);
+					LINK->t = LINK->t->next;
 				}
-				found = (boolean) (LINK->t->kind == tokdata);
+				while (!found || iseos(LINK));
+			}
+			else
 				LINK->t = LINK->t->next;
+			if (v->stringvar)
+			{
+				if (*v->UU.U1.sval != NULL)
+					*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
+				*v->UU.U1.sval = strexpr(LINK);
 			}
-			while (!found || iseos(LINK));
-		}
-		else
-			LINK->t = LINK->t->next;
-		if (v->stringvar)
-		{
-			if (*v->UU.U1.sval != NULL)
-				*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
-			*v->UU.U1.sval = strexpr(LINK);
+			else
+				*v->UU.U0.val = realexpr(LINK);
+#ifdef PHREEQCI_GUI
 		}
-		else
-			*v->UU.U0.val = realexpr(LINK);
+#endif /* PHREEQCI_GUI */
 		datatok = LINK->t;
 		LINK->t = tok;
 		if (!iseos(LINK))
@@ -4804,7 +5170,14 @@
 		dataline = mustfindline(intexpr(LINK), LINK);
 #endif
 		dataline = mustfindline(intexpr(LINK));
-		datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
+		{
+#endif /* PHREEQCI_GUI */
+			datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 	}
 }
 
@@ -4874,7 +5247,15 @@
 		v = LINK->t->UU.vp;
 		LINK->t = LINK->t->next;
 		if (v->numdims != 0)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_ARRAY_ALREADY;
+#endif /* PHREEQCI_GUI */
 			errormsg("Array already dimensioned");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		j = 1;
 		i = 0;
 		require(toklp, LINK);
@@ -4963,6 +5344,13 @@
 			if (V.t != NULL)
 			{
 				V.t = V.t->next;
+#ifdef PHREEQCI_GUI
+				if (WaitForSingleObject(s_hInfiniteLoop, 0) == WAIT_OBJECT_0)
+				{
+					g_nIDErrPrompt = IDS_ERR_INFINITE_LOOP;
+					errormsg("Possible infinite loop");
+				}
+#endif /* PHREEQCI_GUI */
 				switch (stmttok->kind)
 				{
 
@@ -5052,9 +5440,16 @@
 #endif
 
 				case tokinput:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_INPUT_NOTLEGAL;
+					errormsg
+						("Basic command INPUT is not a legal command in PHREEQC.");
+#else /* PHREEQCI_GUI */
 					error_msg
 						("Basic command INPUT is not a legal command in PHREEQC.",
 						 STOP);
+#endif /* PHREEQCI_GUI */
 #ifdef SKIP
 					cmdinput(&V);
 #endif
@@ -5133,6 +5528,10 @@
 					break;
 
 				default:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_ILLEGAL;
+#endif /* PHREEQCI_GUI */
 					errormsg("Illegal command");
 					break;
 				}
@@ -5227,8 +5626,13 @@
 	}
 	if (stmtline != NULL)
 	{
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nErrLineNumber == 0);
+		g_nErrLineNumber = stmtline->num;
+#else /* PHREEQCI_GUI */
 		sprintf(error_string, " in line %ld", stmtline->num);
 		error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	}
 #ifdef SKIP
 	printf(" in %ld", stmtline->num);
