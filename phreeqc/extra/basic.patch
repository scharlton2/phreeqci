--- basic.c	2009-12-02 21:59:49.405074100 -0700
+++ basic1.c	2009-12-02 21:59:04.099244100 -0700
@@ -3,20 +3,30 @@
 
 #if !defined(PHREEQC_CLASS)
 #define EXTERNAL extern
-#include "global.h"
+#include "../src/global.h"
 #else
 typedef unsigned char boolean;
-#include "Phreeqc.h"
+#include "../src/Phreeqc.h"
 #endif
 
-#include "phqalloc.h"
-#include "output.h"
-#include "phrqproto.h"
-#include "p2c.h"
+#include "../src/phqalloc.h"
+#include "../src/output.h"
+#include "../src/phrqproto.h"
+#include "../src/p2c.h"
 #if !defined(PHREEQC_CLASS)
 static char const svnid[] = "$Id: basic.c 3840 2009-12-03 00:47:19Z dlpark $";
 
 int n_user_punch_index;
+
+#ifdef PHREEQCI_GUI
+#define cmd_free        cmd_free_1
+#define cmd_initialize  cmd_initialize_1
+#define basic_renumber  basic_renumber_1
+#define basic_run       basic_run_1
+#define basic_compile   basic_compile_1
+#define basic_main      basic_main_1
+#endif /* PHREEQCI_GUI */
+
 #ifdef PHREEQ98
 void GridChar(char *s, char *a);
 extern int colnr, rownr;
@@ -52,6 +62,10 @@
 		Char *sp;
 		Char snch;
 	} UU;
+#ifdef PHREEQCI_GUI
+	size_t n_sz;
+	Char *sz_num;
+#endif							/* PHREEQCI_GUI */
 } tokenrec;
 
 typedef struct linerec
@@ -120,12 +134,27 @@
 Static tokenrec *stmttok, *datatok, *buf;
 Static boolean exitflag;
 
+#ifdef PHREEQCI_GUI
+Static int parse_whole_program;
+static HANDLE s_hInfiniteLoop = 0;
+UINT g_nIDErrPrompt;
+int g_nErrLineNumber;
+#include "../../resource.h"
+#endif /* PHREEQCI_GUI */
+
 Static int free_dim_stringvar(struct varrec *varbase);
 extern long EXCP_LINE;
 Static void parseinput(tokenrec ** buf);
 Static void exec(void);
 Static void disposetokens(tokenrec ** tok);
 
+#ifdef PHREEQCI_GUI
+int basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+				  int parse_whole_program_flag);
+int basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+			  int parse_whole_program_flag, HANDLE hInfiniteLoop);
+#endif /* PHREEQCI_GUI */
+
 /*$if not checking$
    $range off$
 $end$*/
@@ -475,7 +504,6 @@
  */
 
 	hdestroy_multi(command_hash_table);
-	command_hash_table = NULL;
 	return;
 }
 
@@ -488,11 +516,22 @@
 	return 0;
 }
 #endif
+#ifdef PHREEQCI_GUI
+int
+basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase,
+			  int parse_whole_program_flag)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_compile(char *commands, void **lnbase, void **vbase, void **lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(P_escapecode == 0);
+	_ASSERTE(g_nIDErrPrompt == 0);
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	/*
 	if (svnid == NULL)
 		fprintf(stderr, " ");
@@ -506,6 +545,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	do
 	{
@@ -534,13 +576,21 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			putchar('\n');
+#endif /* PHREEQCI_GUI */
 		}
 		ENDTRY(try2);
 	}
@@ -550,6 +600,9 @@
 	*lnbase = (void *) linebase;
 	*vbase = (void *) varbase;
 	*lpbase = (void *) loopbase;
+#ifndef PHREEQCI_GUI
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
@@ -631,11 +684,22 @@
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+int
+basic_run(char *commands, void *lnbase, void *vbase, void *lpbase,
+		  int parse_whole_program_flag, HANDLE hInfiniteLoop)
+#else /* PHREEQCI_GUI */
 int CLASS_QUALIFIER
 basic_run(char *commands, void *lnbase, void *vbase, void *lpbase)
+#endif							/* PHREEQCI_GUI */
 {								/*main */
 	int l;
 	char *ptr;
+#ifdef PHREEQCI_GUI
+	_ASSERTE(s_hInfiniteLoop == 0);
+	s_hInfiniteLoop = hInfiniteLoop;
+	parse_whole_program = parse_whole_program_flag;
+#endif /* PHREEQCI_GUI */
 	PASCAL_MAIN(0, NULL);
 	inbuf = (char *) PHRQ_calloc(max_line, sizeof(char));
 	if (inbuf == NULL)
@@ -644,6 +708,9 @@
 	varbase = NULL;
 	loopbase = NULL;
 	exitflag = false;
+#ifndef PHREEQCI_GUI
+	cmd_initialize();
+#endif /* PHREEQCI_GUI */
 	ptr = commands;
 	linebase = (linerec *) lnbase;
 	varbase = (varrec *) vbase;
@@ -674,9 +741,13 @@
 #ifdef SKIP
 			printf("Error %d/%d!\n", (int) P_escapecode, (int) P_ioresult);
 #endif
+#ifdef PHREEQCI_GUI
+			_ASSERTE(FALSE);
+#else /* PHREEQCI_GUI */
 			sprintf(error_string, "%d/%d", (int) P_escapecode,
 					(int) P_ioresult);
 			warning_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 		}
 		else
 		{
@@ -688,9 +759,25 @@
 
 	/*  exit(EXIT_SUCCESS); */
 	free(inbuf);
+#ifdef PHREEQCI_GUI
+	s_hInfiniteLoop = 0;
+#else /* PHREEQCI_GUI */
+	cmd_free();
+#endif /* PHREEQCI_GUI */
 	return (P_escapecode);
 }
 
+#ifdef PHREEQCI_GUI
+void
+basic_free(void *lnbase, void *vbase, void *lpbase)
+{
+	basic_run("new; quit", lnbase, vbase, lpbase, FALSE, s_hInfiniteLoop);
+	lnbase = NULL;
+	vbase = NULL;
+	lpbase = NULL;
+}
+#endif /* PHREEQCI_GUI */
+
 int CLASS_QUALIFIER
 basic_main(char *commands)
 {								/*main */
@@ -986,6 +1073,10 @@
 				tptr->next = t;
 			tptr = t;
 			t->next = NULL;
+#ifdef PHREEQCI_GUI
+			t->n_sz = 0;
+			t->sz_num = 0;
+#endif
 			switch (ch)
 			{
 
@@ -1263,9 +1354,9 @@
 							t->kind = tokto;
 						else if (!strcmp(token, "step"))
 							t->kind = tokstep;
-						/*
-						 *   dlp: added functions
-						 */
+/*
+ *   dlp: added functions
+ */
 						else if (!strcmp(token, "tc"))
 							t->kind = toktc;
 						else if (!strcmp(token, "tk"))
@@ -1442,6 +1533,25 @@
 						i++;
 						break;
 					}
+#ifdef PHREEQCI_GUI
+					_ASSERTE(t->n_sz == 0);
+					_ASSERTE(t->sz_num == NULL);
+					t->n_sz = max(23, ptr - &inbuf[i - 1]);
+					t->sz_num =
+						(char *) PHRQ_malloc((t->n_sz + 1) * sizeof(char));
+					if (t->sz_num == NULL)
+						malloc_error();
+					if (ptr > &inbuf[i - 1])
+					{
+						strncpy(t->sz_num, &inbuf[i - 1],
+								(ptr - &inbuf[i - 1]));
+						t->sz_num[ptr - &inbuf[i - 1]] = '\0';
+					}
+					else
+					{
+						t->sz_num[0] = '\0';
+					}
+#endif /* PHREEQCI_GUI */
 					i += (int) (ptr - &inbuf[i - 1]);
 				}
 				else
@@ -2078,6 +2188,18 @@
 	while (*tok != NULL)
 	{
 		tok1 = (*tok)->next;
+#ifdef PHREEQCI_GUI
+		if ((*tok)->kind == (long) toknum)
+		{
+			free((*tok)->sz_num);
+		}
+#ifdef _DEBUG
+		else
+		{
+			_ASSERTE((*tok)->sz_num == NULL);
+		}
+#endif /* _DEBUG */
+#endif /* PHREEQCI_GUI */
 		if ((*tok)->kind == (long) tokrem || (*tok)->kind == (long) tokstr)
 		{
 			(*tok)->UU.sp = (char *) free_check_null((*tok)->UU.sp);
@@ -2151,7 +2273,12 @@
 #ifdef SKIP
 	printf("\007%s", s);
 #endif
+#ifdef PHREEQCI_GUI
+	/* set g_nIDErrPrompt before calling errormsg see snerr */
+	_ASSERTE(g_nIDErrPrompt != 0);
+#else /* PHREEQCI_GUI */
 	error_msg(s, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	_Escape(42);
 }
 
@@ -2161,6 +2288,10 @@
 {
   char str[MAX_LENGTH];
   strcpy(str, "Syntax_error ");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_SYNTAX;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -2170,6 +2301,10 @@
 {
   char str[MAX_LENGTH];
   strcpy(str, "Type mismatch error");
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_MISMATCH;
+#endif /* PHREEQCI_GUI */
   errormsg(strcat(str, s));
 }
 
@@ -2177,6 +2312,10 @@
 Static void CLASS_QUALIFIER
 badsubscr(void)
 {
+#ifdef PHREEQCI_GUI
+	_ASSERTE(g_nIDErrPrompt == 0);
+	g_nIDErrPrompt = IDS_ERR_BAD_SUBSCRIPT;
+#endif /* PHREEQCI_GUI */
 	errormsg("Bad subscript");
 }
 
@@ -2408,7 +2547,9 @@
 	long i, j, m;
 	tokenrec *tok, *tok1;
 	Char *s;
+#ifdef PARSE_ALL
 	LDBLE dummy;
+#endif
 	int i_rate;
 	union
 	{
@@ -2416,7 +2557,9 @@
 		Char *c;
 	} trick;
 	struct save_values s_v, *s_v_ptr;
+#ifdef PARSE_ALL
 	int k;
+#endif
 	LDBLE TEMP;
 	Char STR1[256], STR2[256];
 	char *elt_name, *surface_name, *mytemplate, *name;
@@ -2591,15 +2734,24 @@
 
 	case tokparm:
 		i_rate = intfactor(LINK);
+#ifdef PARSE_ALL
 		if (i_rate > count_rate_p)
 		{
 			errormsg("Parameter subscript out of range.");
 		}
 		n.UU.val = rate_p[i_rate - 1];
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokact:
+#ifdef PARSE_ALL
 		n.UU.val = activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokgamma:
@@ -2635,7 +2787,11 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = diff_layer_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksurf:
@@ -2651,31 +2807,65 @@
 			surface_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = surf_total(elt_name, surface_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokequi:
+#ifdef PARSE_ALL
 		n.UU.val = equi_phase(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokkin:
+#ifdef PARSE_ALL
 		n.UU.val = kinetics_moles(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokgas:
+#ifdef PARSE_ALL
 		n.UU.val = find_gas_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toks_s:
+#ifdef PARSE_ALL
 		n.UU.val = find_s_s_comp(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc1:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc1(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmisc2:
+#ifdef PARSE_ALL
 		n.UU.val = find_misc2(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokmu:
@@ -2698,15 +2888,30 @@
 		break;
 
 	case toklk_species:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_s(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_named:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_n(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toklk_phase:
+#ifdef PARSE_ALL
 		n.UU.val = calc_logk_p(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1;
+#endif
 		break;
 
 	case toksum_species:
@@ -2722,7 +2927,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_species(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_gas:
@@ -2738,7 +2947,11 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_gases(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksum_s_s:
@@ -2754,14 +2967,22 @@
 			elt_name = NULL;
 		}
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = sum_match_s_s(mytemplate, elt_name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokcalc_value:
 		require(toklp, LINK);
 		name = stringfactor(STR1, LINK);
 		require(tokrp, LINK);
+#ifdef PARSE_ALL
 		n.UU.val = get_calculate_value(name);
+#else
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokdescription:
@@ -2987,19 +3208,39 @@
 		break;
 
 	case tokmol:
+#ifdef PARSE_ALL
 		n.UU.val = molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokla:
+#ifdef PARSE_ALL
 		n.UU.val = log_activity(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toklm:
+#ifdef PARSE_ALL
 		n.UU.val = log_molality(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toksr:
+#ifdef PARSE_ALL
 		n.UU.val = saturation_ratio(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokstep_no:
@@ -3025,6 +3266,7 @@
 		}
 		break;
 
+#ifdef PARSE_ALL
 	case tokcell_no:
 		if (state == TRANSPORT)
 		{
@@ -3054,6 +3296,11 @@
 			}
 		}
 		break;
+#else
+	case tokcell_no:
+		n.UU.val = 1;
+		break;
+#endif
 
 	case toksim_no:
 		n.UU.val = simulation;
@@ -3112,10 +3359,18 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
+#else
+		s_v_ptr = NULL;
+#endif
 		if (s_v_ptr == NULL)
 		{
+#ifdef PARSE_ALL
 			n.UU.val = 0;
+#else
+			n.UU.val = 1;
+#endif
 		}
 		else
 		{
@@ -3176,6 +3431,7 @@
 				break;
 			}
 		}
+#ifdef PARSE_ALL
 		s_v_ptr = save_values_bsearch(&s_v, &k);
 		if (s_v_ptr == NULL)
 		{
@@ -3185,6 +3441,9 @@
 		{
 			n.UU.val = 1;
 		}
+#else
+		n.UU.val = 1;
+#endif
 		break;
 
 	case tokcharge_balance:
@@ -3196,11 +3455,21 @@
 		break;
 
 	case toksi:
+#ifdef PARSE_ALL
 		saturation_index(stringfactor(STR1, LINK), &dummy, &n.UU.val);
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case toktot:
+#ifdef PARSE_ALL
 		n.UU.val = total(stringfactor(STR1, LINK));
+#else
+		stringfactor(STR1, LINK);
+		n.UU.val = 1.0;
+#endif
 		break;
 
 	case tokporevolume:
@@ -3424,8 +3693,10 @@
 		}
 		else
 		{
+#ifdef PARSE_ALL
 			sprintf(error_string, "Zero divide in BASIC line\n %ld %s.\nValue set to zero.", stmtline->num, stmtline->inbuf);
 			warning_msg(error_string, CONTINUE);
+#endif
 			n.UU.val = 0;
 		}
 	}
@@ -3595,7 +3866,15 @@
 checkextra(struct LOC_exec *LINK)
 {
 	if (LINK->t != NULL)
+#ifdef PHREEQCI_GUI
+	{
+		_ASSERTE(g_nIDErrPrompt == 0);
+		g_nIDErrPrompt = IDS_ERR_EXTRA;
+#endif /* PHREEQCI_GUI */
 		errormsg("Extra information on line");
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -3645,10 +3924,21 @@
 	l = findline(n, LINK);
 #endif
 	l = findline(n);
-	if (l == NULL) {
-		sprintf(error_string, "Undefined line %ld", n);
-		errormsg(error_string);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (l == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_UNDEF_LINE;
+#endif /* PHREEQCI_GUI */
+			errormsg("Undefined line");
+#ifdef PHREEQCI_GUI
+		}
 	}
+#endif /* PHREEQCI_GUI */
 	return l;
 }
 
@@ -3961,7 +4251,9 @@
 		}
 	}
 
+#ifdef PARSE_ALL
 	save_values_store(&s_v);
+#endif
 	s_v.subscripts = (int *) free_check_null(s_v.subscripts);
 }
 
@@ -4144,7 +4436,14 @@
 						printf("Undefined line %ld in line %ld\n", lnum,
 							   l->num2);
 					else
+#ifdef PHREEQCI_GUI
+					{
+						_snprintf(tok->sz_num, tok->n_sz, "%ld", l1->num2);
+#endif /* PHREEQCI_GUI */
 						tok->UU.num = l1->num2;
+#ifdef PHREEQCI_GUI
+					}
+#endif /* PHREEQCI_GUI */
 					if (tok->next != NULL && tok->next->kind == tokcomma)
 						tok = tok->next;
 				}
@@ -4620,6 +4919,10 @@
 				if (stmtline == NULL || stmtline->next == NULL)
 				{
 					stmtline = saveline;
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_FOR_WO_NEXT;
+#endif /* PHREEQCI_GUI */
 					errormsg("FOR without NEXT");
 				}
 				stmtline = stmtline->next;
@@ -4669,7 +4972,15 @@
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_NEXT_WO_FOR;
+#endif /* PHREEQCI_GUI */
 			errormsg("NEXT without FOR");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == forloop &&
 						   (v == NULL || loopbase->UU.U0.vp == v));
 		if (!found)
@@ -4714,12 +5025,27 @@
 		return;
 	if (realexpr(LINK) != 0)
 		return;
-	if (!skiploop(tokwhile, tokwend, LINK))
-		errormsg("WHILE without WEND");
-	l = loopbase->next;
-	free(loopbase);
-	loopbase = l;
-	skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program == TRUE)
+	{
+#endif /* PHREEQCI_GUI */
+		if (!skiploop(tokwhile, tokwend, LINK))
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WHILE_WO_WEND;
+#endif /* PHREEQCI_GUI */
+			errormsg("WHILE without WEND");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
+		l = loopbase->next;
+		free(loopbase);
+		loopbase = l;
+		skiptoeos(LINK);
+#ifdef PHREEQCI_GUI
+	}
+#endif /* PHREEQCI_GUI */
 }
 
 
@@ -4731,10 +5057,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL || loopbase->kind == gosubloop)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_WEND_WO_WHILE;
+#endif /* PHREEQCI_GUI */
 			errormsg("WEND without WHILE");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == whileloop);
 		if (!found)
 		{
@@ -4794,10 +5134,24 @@
 	looprec *l;
 	boolean found;
 
+#ifdef PHREEQCI_GUI
+	if (parse_whole_program != TRUE)
+	{
+		return;
+	}
+#endif /* PHREEQCI_GUI */
 	do
 	{
 		if (loopbase == NULL)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_RETURN_WO_GOSUB;
+#endif /* PHREEQCI_GUI */
 			errormsg("RETURN without GOSUB");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		found = (boolean) (loopbase->kind == gosubloop);
 		if (!found)
 		{
@@ -4828,37 +5182,52 @@
 		v = findvar(LINK);
 		tok = LINK->t;
 		LINK->t = datatok;
-		if (dataline == NULL)
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
 		{
-			dataline = linebase;
-			LINK->t = dataline->txt;
-		}
-		if (LINK->t == NULL || LINK->t->kind != tokcomma)
-		{
-			do
+#endif /* PHREEQCI_GUI */
+			if (dataline == NULL)
+			{
+				dataline = linebase;
+				LINK->t = dataline->txt;
+			}
+			if (LINK->t == NULL || LINK->t->kind != tokcomma)
 			{
-				while (LINK->t == NULL)
+				do
 				{
-					if (dataline == NULL || dataline->next == NULL)
-						errormsg("Out of Data");
-					dataline = dataline->next;
-					LINK->t = dataline->txt;
+					while (LINK->t == NULL)
+					{
+						if (dataline == NULL || dataline->next == NULL)
+#ifdef PHREEQCI_GUI
+						{
+							_ASSERTE(g_nIDErrPrompt == 0);
+							g_nIDErrPrompt = IDS_ERR_OUT_OF_DATA;
+#endif /* PHREEQCI_GUI */
+							errormsg("Out of Data");
+#ifdef PHREEQCI_GUI
+						}
+#endif /* PHREEQCI_GUI */
+						dataline = dataline->next;
+						LINK->t = dataline->txt;
+					}
+					found = (boolean) (LINK->t->kind == tokdata);
+					LINK->t = LINK->t->next;
 				}
-				found = (boolean) (LINK->t->kind == tokdata);
+				while (!found || iseos(LINK));
+			}
+			else
 				LINK->t = LINK->t->next;
+			if (v->stringvar)
+			{
+				if (*v->UU.U1.sval != NULL)
+					*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
+				*v->UU.U1.sval = strexpr(LINK);
 			}
-			while (!found || iseos(LINK));
-		}
-		else
-			LINK->t = LINK->t->next;
-		if (v->stringvar)
-		{
-			if (*v->UU.U1.sval != NULL)
-				*v->UU.U1.sval = (char *) free_check_null(*v->UU.U1.sval);
-			*v->UU.U1.sval = strexpr(LINK);
+			else
+				*v->UU.U0.val = realexpr(LINK);
+#ifdef PHREEQCI_GUI
 		}
-		else
-			*v->UU.U0.val = realexpr(LINK);
+#endif /* PHREEQCI_GUI */
 		datatok = LINK->t;
 		LINK->t = tok;
 		if (!iseos(LINK))
@@ -4886,7 +5255,14 @@
 		dataline = mustfindline(intexpr(LINK), LINK);
 #endif
 		dataline = mustfindline(intexpr(LINK));
-		datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		if (parse_whole_program == TRUE)
+		{
+#endif /* PHREEQCI_GUI */
+			datatok = dataline->txt;
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 	}
 }
 
@@ -4956,7 +5332,15 @@
 		v = LINK->t->UU.vp;
 		LINK->t = LINK->t->next;
 		if (v->numdims != 0)
+#ifdef PHREEQCI_GUI
+		{
+			_ASSERTE(g_nIDErrPrompt == 0);
+			g_nIDErrPrompt = IDS_ERR_ARRAY_ALREADY;
+#endif /* PHREEQCI_GUI */
 			errormsg("Array already dimensioned before");
+#ifdef PHREEQCI_GUI
+		}
+#endif /* PHREEQCI_GUI */
 		j = 1;
 		i = 0;
 		require(toklp, LINK);
@@ -5036,6 +5420,13 @@
 			if (V.t != NULL)
 			{
 				V.t = V.t->next;
+#ifdef PHREEQCI_GUI
+				if (WaitForSingleObject(s_hInfiniteLoop, 0) == WAIT_OBJECT_0)
+				{
+					g_nIDErrPrompt = IDS_ERR_INFINITE_LOOP;
+					errormsg("Possible infinite loop");
+				}
+#endif /* PHREEQCI_GUI */
 				switch (stmttok->kind)
 				{
 
@@ -5125,9 +5516,16 @@
 #endif
 
 				case tokinput:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_INPUT_NOTLEGAL;
+					errormsg
+						("Basic command INPUT is not a legal command in PHREEQC.");
+#else /* PHREEQCI_GUI */
 					error_msg
 						("Basic command INPUT is not a legal command in PHREEQC.",
 						 STOP);
+#endif /* PHREEQCI_GUI */
 #ifdef SKIP
 					cmdinput(&V);
 #endif
@@ -5206,6 +5604,10 @@
 					break;
 
 				default:
+#ifdef PHREEQCI_GUI
+					_ASSERTE(g_nIDErrPrompt == 0);
+					g_nIDErrPrompt = IDS_ERR_ILLEGAL;
+#endif /* PHREEQCI_GUI */
 					errormsg("Illegal command");
 					break;
 				}
@@ -5305,8 +5707,13 @@
 	}
 	if (stmtline != NULL)
 	{
+#ifdef PHREEQCI_GUI
+		_ASSERTE(g_nErrLineNumber == 0);
+		g_nErrLineNumber = stmtline->num;
+#else /* PHREEQCI_GUI */
 		sprintf(error_string, " in BASIC line\n %ld %s", stmtline->num, stmtline->inbuf);
 		error_msg(error_string, CONTINUE);
+#endif /* PHREEQCI_GUI */
 	}
 #ifdef SKIP
 	printf(" in %ld", stmtline->num);
